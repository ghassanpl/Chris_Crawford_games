UNIT BotP;INTERFACEUSES	Globals, Initialization, NextTurn;PROCEDURE RunStack;IMPLEMENTATION{*****************************************************************}{ECO 4: This is a new procedure}PROCEDURE TimeDelay (Wait: Integer);	VAR		DelayTime: LongInt;	BEGIN		DelayTime := TickCount;		REPEAT		UNTIL (TickCount >= DelayTime + Wait);	END;{*****************************************************************}PROCEDURE TestForColor;{frozen}	VAR		JunkHandle: PixMapHandle;		MacError: OSErr;		theWorld: SysEnvRec;	BEGIN		MacError := SysEnvirons(1, theWorld);		IF theWorld.hasColorQD THEN			BEGIN				JunkHandle := PixMapHandle(MainWind^.portbits.baseAddr);				YesColor := (JunkHandle^^.pixelSize > 1);			END;	END;{*****************************************************************}PROCEDURE DrawScreen;{frozen}	VAR		dstBits: PACKED ARRAY[1..1656] OF byte;		srcPtr: Ptr;		dstPtr: Ptr;		dstBMap: BitMap;		showRect: Rect;		lineRect: Rect;		Scanline: Integer;		i: Integer;	BEGIN		srcPtr := PackedMapPtr;		SetRect(lineRect, 0, 0, 512, 23);		dstBMap.rowBytes := 72;		dstBMap.baseAddr := @dstBits;		SetRect(dstBMap.bounds, 0, 0, 576, 23);		dstPtr := pointer(dstBMap.baseAddr);		SetRect(showRect, 0, 0, 512, 23);		FOR Scanline := 1 TO 14 DO			BEGIN				FOR i := 1 TO 23 DO					UnpackBits(srcPtr, dstPtr, 72);				CopyBits(dstBMap, MainWind^.portbits, lineRect, showRect, srcCopy, NIL);				dstPtr := pointer(dstBMap.baseAddr);				OffsetRect(showRect, 0, 23);			END;	END;{*****************************************************************}PROCEDURE WritePoints (Score: Real);{frozen}	VAR		NumStr: Str255;	BEGIN		IF Score > MaxLongInt THEN			Score := MaxLongInt;		NumToString(Trunc(Score), NumStr);		Move(-StringWidth(NumStr), 0);		DrawString(NumStr);	END;{*****************************************************************}PROCEDURE LoadGame;{frozen}	VAR		dlgOrigin: Point;		theReply: SFReply;		theInfo: FInfo;		theTypeList: SFTypeList;		Ignore: Integer;	BEGIN		SetPt(dlgOrigin, 85, 100);		theTypeList[0] := 'SvGm';		SFGetFile(dlgOrigin, 'Load what saved game?', NIL, 1, theTypeList, NIL, theReply);		IF theReply.good THEN			BEGIN				Error := FSOpen(theReply.fName, theReply.vRefNum, RefNum);				IF Error = NoErr THEN					BEGIN						SetCursor(WatchCursr^^);{ECO 4: Changed a '4' to an '11' here.}						Count := ((MaxNoCards * (MaxConstants + 11)) + (2 * (NoSubsidyCards + NoTaxCards))) * SizeOf(Real);{ECO 4: This next line brings additional global variables into the loaded game}{ECO 6: There was a bad bug in this line; there is also a change for a new variable}						Count := Count + 4 + 5 * SizeOf(Real) + 11 * SizeOf(Rect);						Error := FSRead(RefNum, Count, @InitialTaxValue);{ECO 4: I am now saving the bias file as part of the saved game; this adds these next two lines}						Count := MaxNoCards * MaxConstants * SizeOf(Real);						Error := FSRead(RefNum, Count, @CardConstant);						Error := FSClose(RefNum);{ECO 4: Inserted InvalRect call to force a screen redraw to insure that screen is updated}						InvalRect(MainWind^.portrect); {force screen update; on IBM you will need a more direct approach}						InitCursor;						LoadGameFlag := TRUE;					END;			END;	END;{*****************************************************************}{ECO 6: changed this to a function to return a flag indicating cancellation of the save process.}FUNCTION SaveGame: Boolean;{frozen}	VAR		dlgOrigin: Point;		theReply: SFReply;		theInfo: FInfo;		Ignore: Integer;	BEGIN		SaveGame := FALSE;		SetPt(dlgOrigin, 85, 100);		SFPutFile(dlgOrigin, 'Save this game as:', '', NIL, theReply);		IF theReply.good THEN			BEGIN				Error := GetFInfo(theReply.fName, theReply.vRefNum, theInfo);				IF (Error = NoErr) & (theInfo.fdType <> 'SvGm') THEN					BEGIN						ParamText(theReply.fName, '', '', '');						Ignore := StopAlert(345, NIL);						Exit(SaveGame);					END;				IF Error = FNFErr THEN					Error := Create(theReply.fName, theReply.vRefNum, 'BoPG', 'SvGm');				SetCursor(WatchCursr^^);				Error := FSOpen(theReply.fName, theReply.vRefNum, RefNum);{ECO 4: Changed a '4' to an '11' here.}				Count := ((MaxNoCards * (MaxConstants + 11)) + (2 * (NoSubsidyCards + NoTaxCards))) * SizeOf(Real);{ECO 4: This next line brings additional global variables into the loaded game}{ECO 6: There was a bad bug in this line; there is also a change for a new variable}				Count := Count + 4 + 5 * SizeOf(Real) + 11 * SizeOf(Rect);				Error := FSWrite(RefNum, Count, @InitialTaxValue);{ECO 4: I am now saving the bias file as part of the saved game; this adds these next two lines}				Count := MaxNoCards * MaxConstants * SizeOf(Real);				Error := FSWrite(RefNum, Count, @CardConstant);{ECO 7: one last error check}				IF Error <> 0 THEN					Ignore := StopAlert(346, NIL);				Error := FSClose(RefNum);				SaveGame := TRUE;				InitCursor;			END;	END;{*****************************************************************}PROCEDURE LoadBias;{frozen}	VAR		dlgOrigin: Point;		theReply: SFReply;		theInfo: FInfo;		theTypeList: SFTypeList;		Ignore: Integer;	BEGIN		SetPt(dlgOrigin, 85, 100);		theTypeList[0] := 'Bias';		SFGetFile(dlgOrigin, 'Load what bias file?', NIL, 1, theTypeList, NIL, theReply);		IF theReply.good THEN			BEGIN				Error := FSOpen(theReply.fName, theReply.vRefNum, RefNum);				IF Error = NoErr THEN					BEGIN						SetCursor(WatchCursr^^);						Count := MaxNoCards * MaxConstants * SizeOf(Real);						Error := FSRead(RefNum, Count, @CardConstant);						Error := FSClose(RefNum);						InitCursor;					END;				IF Turn > 0 THEN {ECO 6: this IF-statement is new}					Ignore := StopAlert(158, NIL);			END;	END;{*****************************************************************}PROCEDURE SaveBias;{frozen}	VAR		dlgOrigin: Point;		theReply: SFReply;		theInfo: FInfo;		Ignore: Integer;	BEGIN		SetPt(dlgOrigin, 85, 100);		SFPutFile(dlgOrigin, 'Save as what bias file?', '', NIL, theReply);		IF theReply.good THEN			BEGIN				Error := GetFInfo(theReply.fName, theReply.vRefNum, theInfo);				IF (Error = NoErr) & (theInfo.fdType <> 'Bias') THEN					BEGIN						ParamText(theReply.fName, '', '', '');						Ignore := StopAlert(343, NIL);						Exit(SaveBias);					END;				IF Error = FNFErr THEN					Error := Create(theReply.fName, theReply.vRefNum, 'BoPG', 'Bias');				SetCursor(WatchCursr^^);				Error := FSOpen(theReply.fName, theReply.vRefNum, RefNum);				Count := MaxNoCards * MaxConstants * SizeOf(Real);				Error := FSWrite(RefNum, Count, @CardConstant);{ECO 7: one last error check}				IF Error <> 0 THEN					Ignore := StopAlert(346, NIL);				Error := FSClose(RefNum);				InitCursor;			END;	END;{*****************************************************************}PROCEDURE DoAboutBotP;{frozen}	VAR		x, y: Integer;		CX: Integer;		LoclRect: Rect;		FrogRect: Rect;		TempStrng: Str255;	BEGIN		CX := (MainWind^.portrect.right - MainWind^.portrect.left) DIV 2;		SetRect(LoclRect, CX - 160, 70, CX + 160, 284);		SetRect(FrogRect, CX - 156, 100, CX + 156, 280);		FillRect(FrogRect, white);		PenNormal;		FrameRect(FrogRect);		InsetRect(FrogRect, 4, 4);		PenSize(2, 2);		FrameRect(FrogRect);		PenNormal;		TextSize(18);		TextFont(1);		TextFace([bold]);		TempStrng := 'Balance of the Planet';		x := CX - (StringWidth(TempStrng) DIV 2);		MoveTo(x, 128);		DrawString(TempStrng);		TextSize(12);		TempStrng := 'by Chris Crawford';		x := CX - (StringWidth(TempStrng) DIV 2);		MoveTo(x, 144);		DrawString(TempStrng);		TextFace([]);		TextSize(10);		TempStrng := 'Copyright © 1990 Chris Crawford';		x := CX - (StringWidth(TempStrng) DIV 2);		MoveTo(x, 160);		DrawString(TempStrng);		TempStrng := 'All Rights Reserved    Version 1.10';		x := CX - (StringWidth(TempStrng) DIV 2);		MoveTo(x, 174);		DrawString(TempStrng);		TextSize(12);		TempStrng := 'Art Director: Amanda Goodenough';		x := CX - (StringWidth(TempStrng) DIV 2);		MoveTo(x, 198);		DrawString(TempStrng);		TextSize(10);		TempStrng := 'Special thanks to:';		x := CX - (StringWidth(TempStrng) DIV 2);		MoveTo(x, 214);		DrawString(TempStrng);		TempStrng := 'Brenda Laurel';		x := CX - (StringWidth(TempStrng) DIV 2);		MoveTo(x, 228);		DrawString(TempStrng);		TempStrng := 'Peter & Caitlin Mitchell-Dayton';		x := CX - (StringWidth(TempStrng) DIV 2);		MoveTo(x, 242);		DrawString(TempStrng);		TempStrng := 'Susan Lee-Merrow';		x := CX - (StringWidth(TempStrng) DIV 2);		MoveTo(x, 256);		DrawString(TempStrng);		REPEAT			SystemTask		UNTIL Button;{ECO 6: This chunk of code added for anti-piracy}		LoadScreen('Kathy&Chris');		IF PackedSize = 16116 THEN {This prevents them from putting mustaches on Kathy}			DrawScreen		ELSE			FOR x := 1 TO 100 DO				SysBeep(10);		REPEAT		UNTIL NOT Button;		REPEAT			SystemTask;		UNTIL Button;		CASE JumpLocation OF			EarthProc: 				LoadScreen('Earth');			PointProc: 				LoadScreen('Results');			MoneyProc: 				LoadScreen('Policies');			TreeProc: 				LoadScreen('Feedback');			OTHERWISE				LoadCard;		END;		FlushEvents(EveryEvent, 0);		InvalRect(MainWind^.portRect);	END;{*****************************************************************}PROCEDURE DoCommand (mResult: LongInt);{frozen}	CONST		AppleMenu = 8;		FileMenu = 9;		PoliciesCase = 1;		ResultsCase = 2;		FormulaCase = 3;		ExecuteCase = 4;		LoadGameCase = 5;		SaveGameCase = 6;		LoadBiasCase = 7;		SaveBiasCase = 8;		QuitGameCase = 9;	VAR		theMenu: Integer;		theItem: Integer;		x, AlertNumber: Integer;		DAName: Str255;		SavedFlag: Boolean;	BEGIN		theMenu := HiWord(mResult);		theItem := LoWord(mResult);		CASE theMenu OF			AppleMenu: 				BEGIN					IF theItem = 1 THEN						DoAboutBotP					ELSE						BEGIN							GetItem(MenuArr[1], theItem, DAName);							x := OpenDeskAcc(DAName);						END;				END;			FileMenu: 				CASE theItem OF					PoliciesCase: 						BEGIN							ExitFlag := TRUE;							JumpLocation := MoneyProc;						END;					ResultsCase: 						BEGIN							ExitFlag := TRUE;							JumpLocation := PointProc;						END;					ExecuteCase:{ECO 6: Note new arguement of NextTurn}						NextTurn(5);					FormulaCase: 						BEGIN							ExitFlag := TRUE;							JumpLocation := FormulaProc;						END;					LoadGameCase: 						LoadGame;					SaveGameCase: 						SavedFlag := SaveGame;					LoadBiasCase: 						LoadBias;					SaveBiasCase: 						SaveBias;{ECO 6: some changes in QuitGameCase to handle a "save before quit?" option}					QuitGameCase: 						BEGIN							InitCursor;							x := StopAlert(157, NIL);							SavedFlag := TRUE;							IF x = 1 THEN								SavedFlag := SaveGame;							IF (x < 3) & SavedFlag THEN								BEGIN									ExitFlag := TRUE;									QuitGame := TRUE;								END;						END;				END;			OTHERWISE				BEGIN {spoof the compiler}				END;		END;		IF NOT QuitFlag THEN			HiliteMenu(0);	END;{*****************************************************************}PROCEDURE KeyHandler;{frozen}	VAR		x: Integer;		ch: Char;	BEGIN		x := BitAnd(MyEvent.message, CharCodeMask);		IF BitAnd(MyEvent.modifiers, CmdKey) <> 0 THEN			BEGIN				ch := Chr(x);				DoCommand(MenuKey(ch));			END		ELSE			BEGIN				IF (x = 13) & (JumpLocation = FormulaProc) THEN					BEGIN						JumpLocation := CardProc;						ExitFlag := TRUE;					END;{ECO 6: this IF-statement added to support TreeProc}				IF (x = 13) & (JumpLocation = TreeProc) THEN					BEGIN						JumpLocation := PointProc;						ExitFlag := TRUE;					END;			END;	END;{*****************************************************************}PROCEDURE RunEarth;{frozen}	BEGIN		LoadScreen('Earth');		DrawScreen;		ExitFlag := FALSE;		REPEAT			SystemTask;			IF GetNextEvent(everyEvent, MyEvent) THEN				BEGIN					TestForColor;					CASE MyEvent.what OF						KeyDown: 							BEGIN								JumpLocation := PointProc;								ExitFlag := TRUE;								KeyHandler;							END;						UpdateEvt: 							BEGIN								GetPort(SavePort);								whichWindow := WindowPtr(MyEvent.message);								SetPort(whichWindow);								BeginUpdate(whichWindow);								DrawScreen;								EndUpdate(MainWind);								SetPort(SavePort);							END;						mouseDown: 							BEGIN								thePart := FindWindow(MyEvent.where, whichWindow);								CASE thePart OF									InDrag: 										DoDrag;									InMenuBar: 										DoCommand(MenuSelect(MyEvent.where));									InSysWindow: 										SystemClick(MyEvent, whichWindow);									OTHERWISE										BEGIN {force an exit to the the policy screen}											JumpLocation := PointProc;											ExitFlag := TRUE;										END;								END; {thePart CASE}							END; {mousedown instance}						OTHERWISE {isn't it unsettling to see the programmer defeating Pascal's paternalism?}					END;				END; {GetNextEvent IF}		UNTIL ExitFlag;{ECO 6: New line of code here; VERY IMPORTANT CHANGE!!!}		IF NOT LoadGameFlag THEN			NextTurn(1);	END;{*****************************************************************}PROCEDURE WriteYear;{frozen}	VAR		TempStr: Str255;	BEGIN		TextFont(2);		TextSize(18);		NumToString(ord4(Year), TempStr);		DrawString(TempStr);	END;{*****************************************************************}PROCEDURE RunPoints;{frozen}	VAR		i: Integer;		InversePosIndex: ARRAY[1..16] OF Integer;		InverseNegIndex: ARRAY[1..16] OF Integer;		MaxPosIndeces: Integer;		MaxNegIndeces: Integer;		TempRect: Rect;		EarthRect: Rect;		LongX: LongInt;		NumStr: Str255;		MousePt: Point;		CursorFlag: Boolean;{ECO 6: New rect for feedback feature}		FeedbackRect: Rect;{-------------------------------------------------------------------------------------------}	PROCEDURE ContaminateMultiFinder;{frozen}		VAR			i, j, y: Integer;			TempStr: Str255;		BEGIN			DrawScreen;			TextMode(srcXOr);			PenMode(PatXOr);			TextFont(2);{ECO 6: I moved everything up by six pixels}			MoveTo(30, 54);			TextSize(14);			DrawString('Positive Points');{ECO 6: I moved everything up by six pixels}			MoveTo(370, 54);			DrawString('Negative Points');{ECO 6: added these seven lines}			TextFont(0);			TextSize(12);			TempStr := 'Feedback';			MoveTo(256 - (StringWidth(TempStr) DIV 2), 74);			DrawString(TempStr);			FrameRect(FeedbackRect);{ECO 6: I commented out the calculation of Points from these loops}{Points := 0;}			TextFont(1);			TextSize(10);{ECO 6: I moved everything up by six pixels}			y := 74;			j := 0;			FOR i := 1 TO MaxNoCards DO				BEGIN					IF CardType[i] = LifePtsCard THEN						BEGIN							MoveTo(20, y);							DrawString(CardName[i]);							MoveTo(170, y);							WritePoints(CardValue[i]);							y := y + 14;							j := j + 1;							InversePosIndex[j] := i;{Points := Points + CardValue[i];}						END;				END; {i-loop}			MaxPosIndeces := j;{ECO 6: I moved everything up by six pixels}			y := 74;			j := 0;			FOR i := 1 TO MaxNoCards DO				BEGIN					IF CardType[i] = DeathPtsCard THEN						BEGIN							MoveTo(340, y);							DrawString(CardName[i]);							MoveTo(490, y);							WritePoints(CardValue[i]);							y := y + 14;							j := j + 1;							InverseNegIndex[j] := i;{Points := Points - CardValue[i];}						END;				END; {i-loop}			MaxNegIndeces := j;			TextFont(2);			TextSize(18);			NumToString(ord4(Year), TempStr);			TempStr := Concat('Results for ', TempStr);			MoveTo(256 - (StringWidth(TempStr) DIV 2), 30);			DrawString(TempStr);			TextSize(14);			LongX := Trunc(Points);			NumToString(LongX, NumStr);			TempStr := Concat('Total Points: ', NumStr);{ECO 6: I moved everything up by six pixels}			MoveTo(256 - (StringWidth(TempStr) DIV 2), 54);			DrawString(TempStr);			PenNormal;		END;{-------------------------------------------------------------------------------------------}	BEGIN{ECO 6: define FeedbackRect}		SetRect(FeedbackRect, 220, 60, 292, 80);		LoadScreen('Results');		IF Turn < 10 THEN{ECO 6: changed 3 to 4}			EnableItem(MenuArr[2], 4);{ECO 4: this loop is new}{ECO 6: incremented the beginning point and endpoint of this loop}		FOR i := 5 TO 8 DO			EnableItem(MenuArr[2], i);		DisableItem(MenuArr[2], 7); {ECO 6: mask out load bias option}		ContaminateMultiFinder;		ExitFlag := FALSE;		REPEAT			SystemTask;			GetMouse(MousePt);			CursorFlag := FALSE;			IF PtInRect(MousePt, FeedbackRect) THEN				CursorFlag := TRUE;			FOR i := 1 TO MaxPosIndeces DO				BEGIN{ECO 6: I moved everything up by six pixels}					SetRect(TempRect, 20, 48 + 14 * i, 176, 64 + 14 * i);					IF PtInRect(MousePt, TempRect) THEN						CursorFlag := TRUE;				END; {i-loop}			FOR i := 1 TO MaxNegIndeces DO				BEGIN{ECO 6: I moved everything up by six pixels}					SetRect(TempRect, 340, 48 + 14 * i, 500, 64 + 14 * i);					IF PtInRect(MousePt, TempRect) THEN						CursorFlag := TRUE;				END; {i-loop}			IF CursorFlag THEN				SetCursor(MaltaKreuz^^)			ELSE				InitCursor;			IF GetNextEvent(everyEvent, MyEvent) THEN				BEGIN					TestForColor;					CASE MyEvent.what OF						KeyDown: 							KeyHandler;						UpdateEvt: 							BEGIN								GetPort(SavePort);								whichWindow := WindowPtr(MyEvent.message);								SetPort(whichWindow);								BeginUpdate(whichWindow);								ContaminateMultiFinder;								EndUpdate(MainWind);								SetPort(SavePort);							END;						mouseDown: 							BEGIN								thePart := FindWindow(MyEvent.where, whichWindow);								CASE thePart OF									InDrag: 										DoDrag;									InMenuBar: 										DoCommand(MenuSelect(MyEvent.where));									InSysWindow: 										SystemClick(MyEvent, whichWindow);									InContent: 										IF whichWindow <> FrontWindow THEN											SelectWindow(whichWindow)										ELSE											BEGIN												GlobalToLocal(MyEvent.where);												FOR i := 1 TO MaxPosIndeces DO													BEGIN{ECO 6: I moved everything up by six pixels}														SetRect(TempRect, 20, 48 + 14 * i, 176, 64 + 14 * i);														IF PtInRect(MyEvent.where, TempRect) THEN															BEGIN																IF HoldThatClick(TempRect) THEN																	BEGIN																		ExitFlag := TRUE;																		ThisCard := InversePosIndex[i];																		JumpLocation := CardProc;																	END;															END;													END; {i-loop}												FOR i := 1 TO MaxNegIndeces DO													BEGIN{ECO 6: I moved everything up by six pixels}														SetRect(TempRect, 340, 48 + 14 * i, 500, 64 + 14 * i);														IF PtInRect(MyEvent.where, TempRect) THEN															BEGIN																IF HoldThatClick(TempRect) THEN																	BEGIN																		ExitFlag := TRUE;																		ThisCard := InverseNegIndex[i];																		JumpLocation := CardProc;																	END;															END;													END; {i-loop}{ECO 6: add entry point for feedback}												IF PtInRect(MyEvent.where, FeedbackRect) THEN													BEGIN														IF HoldThatClick(FeedbackRect) THEN															BEGIN																ExitFlag := TRUE;																JumpLocation := TreeProc;															END;													END;											END;									OTHERWISE {spoof the damn compiler}								END; {thePart CASE}							END; {mousedown instance}						OTHERWISE {isn't it unsettling to see the programmer pummeling Pascal's paternalism?}					END;				END; {GetNextEvent IF}		UNTIL ExitFlag;{ECO 4: this loop is new}{ECO 6: changed endpoints of loop}		FOR i := 4 TO 8 DO			DisableItem(MenuArr[2], i);	END;{*****************************************************************}PROCEDURE WriteMoney (Moolah: Real);{frozen}	VAR		TempMoney: Real;		TempStr: Str255;	BEGIN		TempMoney := Moolah / 1e9;		TempStr := StringOf(TempMoney : 4 : 2);		Move(-StringWidth(TempStr), 0);		DrawString('$');		DrawString(TempStr);	END;{*****************************************************************}PROCEDURE RunMoney;{frozen}	VAR		i, j: Integer;		TempRect: Rect;		CursorFlag: Boolean;		MousePt: Point;{-------------------------------------------------------------------------------------------}	PROCEDURE PoisonMultiFinder;{frozen}		VAR			i, j, y: Integer;			Income: Real;			Expense: Real;{ECO 5: New variable here}			SumPercentage: Real;			TempStr: Str255;		BEGIN			DrawScreen;			TextFont(2);			MoveTo(28, 54);			TextSize(12);			DrawString('Source');			MoveTo(100, 54);			DrawString('Tax Rate');{ECO 6: I moved the Income column right 10 pixels to accomodate 7-digit numbers.}{This implied a great many petty changes. I also moved the Item column and the %-age}{column left 10 pixels for similar reasons. Since your code is dramatically different here,}{I am not flagging every single change, just the underlying one.}			MoveTo(218, 54);			DrawString('Income');			MoveTo(290, 54);			DrawString('Item');			MoveTo(440, 54);			DrawString('Expense');			TextSize(9);			MoveTo(218, 65);			DrawString('(billion)');			MoveTo(450, 65);			DrawString('(billion)');			Income := 0;			Expense := 0;			y := 80;			FOR j := 1 TO NoTaxCards DO				BEGIN					i := TaxIndex[j];					MoveTo(20, y);					TextFont(1);					TextSize(10);					DrawString(CardName[i]);					TextFont(4);					TextSize(9);					MoveTo(110, y);					MyFloatWrite(TaxValue[j]);					MoveTo(248, y);					WriteMoney(CardValue[i]);					y := y + 14;					Income := Income + CardValue[i];				END; {i-loop}			MoveTo(218, y - 12);			LineTo(254, y - 12);			MoveTo(248, y);			WriteMoney(Income);{ECO 5: Some new statements scattered through here involving SumPercentage}			SumPercentage := 0;			y := 80;			FOR j := 1 TO NoSubsidyCards DO				BEGIN					i := SubsidyIndex[j];					TextFont(1);					TextSize(10);					MoveTo(290, y);					DrawString(CardName[i]);					TextFont(4);					TextSize(9);					IF i <> PropertyDamage%S THEN						BEGIN							MoveTo(410, y);{ECO 5: I changed the call from SubWrite to WritePoints; it now right-justifies the value}							WritePoints(SubsidyValue[j]);							DrawString('%');							SumPercentage := SumPercentage + SubsidyValue[j];						END;					MoveTo(480, y);					WriteMoney(CardValue[i]);					y := y + 14;					Expense := Expense + CardValue[i];				END; {i-loop}			MoveTo(450, y - 12);			LineTo(486, y - 12);			MoveTo(480, y);			WriteMoney(Expense);{ECO 5: Now draw in SumPercentage}			MoveTo(392, y - 12);			LineTo(416, y - 12);			MoveTo(410, y);			WritePoints(SumPercentage);			DrawString('%');			TextFont(2);			TextSize(18);			NumToString(ord4(Year), TempStr);			TempStr := Concat('Policy Summary for ', TempStr);			MoveTo(256 - (StringWidth(TempStr) DIV 2), 30);			DrawString(TempStr);			MoveTo(150, 300);			DrawString('Treasury:');			Move(70, 0);			WriteMoney(Income - Expense);			DrawString(' billion');		END;{-------------------------------------------------------------------------------------------}	BEGIN		LoadScreen('Policies');		IF Turn < 10 THEN{ECO 6: changed 3 to 4}			EnableItem(MenuArr[2], 4);{ECO 4: this loop is new}{ECO 6: incremented the beginning point and endpoint of this loop}		FOR i := 5 TO 8 DO			EnableItem(MenuArr[2], i);		DisableItem(MenuArr[2], 7); {ECO 6: mask out load bias option}		PoisonMultiFinder;		ExitFlag := FALSE;		REPEAT			SystemTask;			CursorFlag := FALSE;			GetMouse(MousePt);			FOR i := 1 TO NoTaxCards DO				BEGIN{ECO 4: extended the rectangle on both left and right sides}					SetRect(TempRect, 18, 54 + 14 * i, 248, 70 + 14 * i);					IF PtInRect(MousePt, TempRect) THEN						CursorFlag := TRUE;				END; {i-loop}			FOR i := 1 TO NoSubsidyCards DO				BEGIN					SetRect(TempRect, 295, 54 + 14 * i, 496, 70 + 14 * i);					IF PtInRect(MousePt, TempRect) THEN						CursorFlag := TRUE;				END; {i-loop}			IF CursorFlag THEN				SetCursor(MaltaKreuz^^)			ELSE				InitCursor;			IF GetNextEvent(everyEvent, MyEvent) THEN				BEGIN					TestForColor;					CASE MyEvent.what OF						KeyDown: 							KeyHandler;						UpdateEvt: 							BEGIN								GetPort(SavePort);								whichWindow := WindowPtr(MyEvent.message);								SetPort(whichWindow);								BeginUpdate(whichWindow);								PoisonMultiFinder;								EndUpdate(MainWind);								SetPort(SavePort);							END;						mouseDown: 							BEGIN								thePart := FindWindow(MyEvent.where, whichWindow);								CASE thePart OF									InDrag: 										DoDrag;									InMenuBar: 										DoCommand(MenuSelect(MyEvent.where));									InSysWindow: 										SystemClick(MyEvent, whichWindow);									InContent: 										IF whichWindow <> FrontWindow THEN											SelectWindow(whichWindow)										ELSE											BEGIN												GlobalToLocal(MyEvent.where);												FOR i := 1 TO NoTaxCards DO													BEGIN{ECO 4: extended the rectangle on both left and right sides}{ECO 6: extended the rectangle to the right 10 pixels}														SetRect(TempRect, 18, 54 + 14 * i, 258, 70 + 14 * i);														IF PtInRect(MyEvent.where, TempRect) THEN															BEGIN																IF HoldThatClick(TempRect) THEN																	BEGIN																		ExitFlag := TRUE;																		ThisCard := TaxIndex[i];																		JumpLocation := CardProc;																	END;															END;													END; {i-loop}												FOR i := 1 TO NoSubsidyCards DO													BEGIN{ECO 6: extended the rectangle to the left 10 pixels}														SetRect(TempRect, 285, 54 + 14 * i, 496, 70 + 14 * i);														IF PtInRect(MyEvent.where, TempRect) THEN															BEGIN																IF HoldThatClick(TempRect) THEN																	BEGIN																		ExitFlag := TRUE;																		ThisCard := SubsidyIndex[i];																		JumpLocation := CardProc;																	END;															END;													END; {i-loop}											END;									OTHERWISE {spoof the damn compiler}								END; {thePart CASE}							END; {mousedown instance}						OTHERWISE {isn't it unsettling to see the programmer defeating Pascal's paternalism?}					END;				END; {GetNextEvent IF}		UNTIL ExitFlag;{ECO 4: this loop is new}{ECO 6: incremented endpoints of loop}		FOR i := 4 TO 8 DO			DisableItem(MenuArr[2], i);	END;{*****************************************************************}PROCEDURE JumpConstant;{frozen}	VAR		TempRect: Rect;		RealX: Real;	BEGIN		RealX := CardCLLimit[WhichConstant] + GetCtlValue(ScrollConstant[WhichConstant]) * (CardCULimit[WhichConstant] - CardCLLimit[WhichConstant]) / 1000;		SetRect(TempRect, 200, 60 + 24 * WhichConstant, 293, 76 + 24 * WhichConstant);		FillRect(TempRect, white);		TextFont(1);		TextSize(12);		MoveTo(200, 72 + 24 * WhichConstant);		MyFloatWrite(RealX);		CardConstant[ThisCard, WhichConstant] := RealX;		TimeDelay(4); {ECO 4: inserted this line}	END;{************************************************************************}PROCEDURE ConstantScroll (theControl: ControlHandle; thisPart: Integer);{frozen}	VAR		delta: Integer;		OldValue: Integer;		x: Integer;	BEGIN{ECO 6: I lowered the increments used here to give the player more precise control}		CASE thisPart OF			inUpButton: 				delta := -1;			inDownButton: 				delta := 1;			inPageUp: 				delta := -50;			inPageDown: 				delta := 50;			OTHERWISE				delta := 0;		END;		IF thisPart <> 0 THEN			BEGIN				oldValue := GetCtlValue(theControl);				SetCtlValue(theControl, oldValue + delta);				IF GetCtlValue(theControl) <> oldValue THEN					JumpConstant;			END;	END;{************************************************************************}PROCEDURE RunTree;{frozen}	CONST		PointCount = 17;	VAR		i, j, k, x, y: Integer;		ExitRect: Rect;		TempRect: Rect;		LongX: LongInt;		MousePt: Point;		SortedPoints: ARRAY[1..PointCount] OF Real;		GoodOrBad: ARRAY[1..PointCount] OF Boolean;		Inversion: ARRAY[1..PointCount] OF Integer;		Improvement: Real;		LastTurn: Integer;{-------------------------------------------------------------------------------------------}	PROCEDURE ShowTree;{frozen}		VAR			i, j: Integer;			CardRect: Rect;			TempStr: Str255;			NumStr: Str255;		BEGIN			SetRect(CardRect, 0, 0, 512, BitMapHeight);			FillRect(CardRect, black);			DrawScreen;			TextMode(srcXOr);			PenMode(PatXOr);			TextFont(2);			TextSize(18);			TextFace([Bold]);			TempStr := 'Feedback for this turn';			MoveTo(120, 24);			DrawString(TempStr);			y := 72;			TextFont(1);			TextSize(10);			TextFace([]);			SetRect(ExitRect, BaseX + 24, y - 14, BaseX + 96, y + 6);			FrameRect(ExitRect);			MoveTo(BaseX + 32, y);			TextSize(12);			TextFont(0);			DrawString('Return');			TextFont(2);			TextSize(14);			IF Points - LastPoints > 0 THEN				BEGIN					LongX := Trunc(Points - LastPoints);					TempStr := ' up by ';				END			ELSE				BEGIN					LongX := Trunc(LastPoints - Points);					TempStr := ' down by ';				END;			NumToString(LongX, NumStr);			TempStr := Concat('Overall, your score went', TempStr, NumStr, ' points');			MoveTo(78, 50);			DrawString(TempStr);			MoveTo(60, 90);			DrawString('Problems');			TextSize(12);			y := 110;			i := 1;			j := 0;			WHILE (i < PointCount) & (SortedPoints[i] > 10) & (j < 5) DO				BEGIN					IF NOT GoodOrBad[i] THEN						BEGIN							MoveTo(10, y);							DrawString(CardName[Inversion[i]]);							DrawString(' worsened by ');							LongX := Trunc(SortedPoints[i]);							NumToString(LongX, NumStr);							DrawString(NumStr);							y := y + 16;							j := j + 1;						END;					i := i + 1;				END;			TextSize(14);			MoveTo(350, 90);			DrawString('Successes');			TextSize(12);			y := 110;			i := 1;			j := 0;			WHILE (i < PointCount) & (SortedPoints[i] > 10) & (j < 5) DO				BEGIN					IF GoodOrBad[i] THEN						BEGIN							MoveTo(270, y);							DrawString(CardName[Inversion[i]]);							DrawString(' improved by ');							LongX := Trunc(SortedPoints[i]);							NumToString(LongX, NumStr);							DrawString(NumStr);							y := y + 16;							j := j + 1;						END;					i := i + 1;				END;		END;{-------------------------------------------------------------------------------------------}	BEGIN		LoadScreen('Feedback');		IF Turn > 1 THEN			LastTurn := Turn - 1		ELSE			LastTurn := 1;		FOR i := 1 TO PointCount DO			SortedPoints[i] := 0;		FOR i := 1 TO MaxNoCards DO			BEGIN				IF CardType[i] = LifePtsCard THEN					BEGIN						Improvement := Abs(CardValue[i] - CardHistory[i, LastTurn]);						j := 1;						WHILE (j <= PointCount) & (Improvement < SortedPoints[j]) DO							j := j + 1;						FOR k := PointCount DOWNTO j + 1 DO							BEGIN								SortedPoints[k] := SortedPoints[k - 1];								Inversion[k] := Inversion[k - 1];								GoodOrBad[k] := GoodOrBad[k - 1];							END;						SortedPoints[j] := Improvement;						Inversion[j] := i;						GoodOrBad[j] := CardValue[i] > CardHistory[i, LastTurn];					END;				IF CardType[i] = DeathPtsCard THEN					BEGIN						Improvement := Abs(CardHistory[i, LastTurn] - CardValue[i]);						j := 1;						WHILE (j <= PointCount) & (Improvement < SortedPoints[j]) DO							j := j + 1;						FOR k := PointCount DOWNTO j + 1 DO							BEGIN								SortedPoints[k] := SortedPoints[k - 1];								Inversion[k] := Inversion[k - 1];								GoodOrBad[k] := GoodOrBad[k - 1];							END;						SortedPoints[j] := Improvement;						Inversion[j] := i;						GoodOrBad[j] := CardValue[i] < CardHistory[i, LastTurn];					END;			END; {i-loop}		ShowTree;		ExitFlag := FALSE;		FlushEvents(EveryEvent, 0);		REPEAT			SystemTask;			GetMouse(MousePt);			IF PtInRect(MousePt, ExitRect) THEN				SetCursor(MaltaKreuz^^)			ELSE				InitCursor;			IF GetNextEvent(everyEvent, MyEvent) THEN				BEGIN					TestForColor;					CASE MyEvent.what OF						KeyDown: 							KeyHandler;						UpdateEvt: 							BEGIN								GetPort(SavePort);								whichWindow := WindowPtr(MyEvent.message);								SetPort(whichWindow);								BeginUpdate(whichWindow);								ShowTree;								EndUpdate(MainWind);								SetPort(SavePort);							END;						mousedown: 							BEGIN								thePart := FindWindow(myEvent.where, whichWindow);								CASE thePart OF									InDrag: 										DoDrag;									InMenuBar: 										DoCommand(MenuSelect(MyEvent.where));									InSysWindow: 										SystemClick(MyEvent, whichWindow);									InContent: 										IF whichWindow <> FrontWindow THEN											SelectWindow(whichWindow)										ELSE											BEGIN												GlobalToLocal(MyEvent.where);												IF PtInRect(MyEvent.where, ExitRect) THEN													BEGIN														IF HoldThatClick(ExitRect) THEN															BEGIN																ExitFlag := TRUE;																JumpLocation := PointProc;															END;													END;											END;								END;							END;						OTHERWISE							BEGIN {Spoof the compiler}							END;					END;				END;		UNTIL ExitFlag | QuitGame;	END;{************************************************************************}PROCEDURE RunFormula;{frozen}	CONST		OriginX = 240;		OriginY = 60;	VAR		i, j, k, x, y: Integer;		CardRect: Rect;		ExitRect: Rect;		TempRect: Rect;		LongX: LongInt;		LocalExit: Boolean;		NumString: Str255;		TempStr: Str255;		PenPosition: Point;		DelayTime: LongInt;		EndTime: LongInt;		MousePt: Point;		StartIndex: Integer;		EndIndex: Integer;		EndFlag: Boolean;		LastChar: Integer;		TestStr: Str255;		RealX: Real;		ThisULimit: Real;		ThisLLimit: Real;		ScrollValue: Integer;		JunkPart: Integer;{-------------------------------------------------------------------------------------------}	PROCEDURE EquateMultiFinder;{frozen}		VAR			i, j: Integer;			ThatCard: Integer;		BEGIN			SetRect(CardRect, 0, 0, 512, BitMapHeight);			FillRect(CardRect, white);			TextFont(2);			TextSize(18);			TextFace([Bold]);			TempStr := Concat('Formula for ', CardName[ThisCard]);			x := StringWidth(TempStr) DIV 2;			MoveTo(256 - x, 24);			DrawString(TempStr);			y := 48;			TextFont(1);			TextSize(10);			TextFace([]);			TempStr := Concat(CardName[ThisCard], ' = ', PEquationStr);			IF EquationLength < 2 THEN				BEGIN					TempStr := Concat('There is no formula for ', CardName[ThisCard]);{ECO 5: I added these next two lines to provide some explanation to the user}					MoveTo(80, y + 14);					DrawString('Since you control this value directly, there is no need for a formula.');				END;			x := StringWidth(TempStr) DIV 2;			MoveTo(256 - x, y);			DrawString(TempStr);			y := y + 24;			IF CConstantText[1] <> '' THEN				BEGIN					MoveTo(20, y);					TextFont(1);					TextSize(12);					DrawString('Where:');				END;			SetRect(ExitRect, BaseX + 24, y - 14, BaseX + 96, y + 6);			FrameRect(ExitRect);			MoveTo(BaseX + 32, y);			TextSize(12);			TextFont(0);			DrawString('Return');			DrawControls(MainWind);			TextFont(1);			TextSize(12);			y := y + 24;			i := 1;			WHILE (i <= MaxConstants) & (CConstantText[i] <> '') DO				BEGIN					MoveTo(10, y);					DrawString(CConstantText[i]);					MoveTo(OriginX - 60, y);					DrawString('=');					MoveTo(OriginX - 40, y);					MyFloatWrite(CardConstant[ThisCard, i]);					IF CConstantUnits[i] <> '' THEN						BEGIN							MoveTo(OriginX + 150, y);							DrawString(Concat('(', CConstantUnits[i], ')'));						END;					i := i + 1;					y := y + 24;				END;{Now list the relevant variables and their values.}			i := 1;			WHILE (i <= MaxConstants) & (CVariable[i] > 0) DO				BEGIN					ThatCard := CVariable[i];					MoveTo(10, y);					DrawString(CardName[ThatCard]);					MoveTo(OriginX - 60, y);					DrawString('=');					MoveTo(OriginX - 40, y);{ECO 4: replaced simple MyFloatWrite call with IF-statement and two MyFloatWrite calls}					IF CardType[ThatCard] = TaxCard THEN						MyFloatWrite(TaxValue[InversionIndex[ThatCard]])					ELSE						MyFloatWrite(CardValue[ThatCard]);					IF CardUnit[ThatCard] <> '' THEN						BEGIN							MoveTo(OriginX + 150, y);							DrawString(Concat('(', CardUnit[ThatCard], ')'));						END;					i := i + 1;					y := y + 20;				END;			y := y + 8;			TextFont(2);			TextSize(12);			IF EquationLength > 1 THEN				BEGIN					StartIndex := ExplanationMark;					EndFlag := FALSE;					REPEAT						EndIndex := StartIndex + 76;						IF EndIndex >= EquationLength THEN							BEGIN								EndFlag := TRUE;								EndIndex := EquationLength;							END						ELSE							BEGIN								REPEAT									EndIndex := EndIndex - 1								UNTIL EquationText[EndIndex] = ' ';							END;						TestStr := '';						FOR j := StartIndex TO EndIndex DO							TestStr := Concat(TestStr, EquationText[j]);						StartIndex := EndIndex + 1;						MoveTo(12, y);						DrawString(TestStr);						y := y + 15;					UNTIL EndFlag;				END; {of EquationLength>0 IF}		END;{-------------------------------------------------------------------------------------------}	BEGIN		IF PScrollFlag THEN			HideControl(PolicyScroll);		y := 96;		i := 1;		WHILE (i <= MaxConstants) & (CConstantText[i] <> '') DO			BEGIN				SetRect(TempRect, OriginX + 54, y - 12, OriginX + 144, y + 4);				ScrollValue := trunc(1000 * (CardConstant[ThisCard, i] - CardCLLimit[i]) / (CardCULimit[i] - CardCLLimit[i]));				ScrollConstant[i] := NewControl(MainWind, TempRect, '', TRUE, ScrollValue, 0, 1000, ScrollBarProc, 0);				i := i + 1;				y := y + 24;			END;		EquateMultiFinder;		ExitFlag := FALSE;		FlushEvents(EveryEvent, 0);		REPEAT			SystemTask;			GetMouse(MousePt);			IF PtInRect(MousePt, ExitRect) THEN				SetCursor(MaltaKreuz^^)			ELSE				InitCursor;			IF GetNextEvent(everyEvent, MyEvent) THEN				BEGIN					TestForColor;					CASE MyEvent.what OF						KeyDown: 							KeyHandler;						UpdateEvt: 							BEGIN								GetPort(SavePort);								whichWindow := WindowPtr(MyEvent.message);								SetPort(whichWindow);								BeginUpdate(whichWindow);								EquateMultiFinder;								EndUpdate(MainWind);								SetPort(SavePort);							END;						mousedown: 							BEGIN								thePart := FindWindow(myEvent.where, whichWindow);								CASE thePart OF									InDrag: 										DoDrag;									InMenuBar: 										DoCommand(MenuSelect(MyEvent.where));									InSysWindow: 										SystemClick(MyEvent, whichWindow);									InContent: 										IF whichWindow <> FrontWindow THEN											SelectWindow(whichWindow)										ELSE											BEGIN												GlobalToLocal(MyEvent.where);												IF PtInRect(MyEvent.where, ExitRect) THEN													BEGIN														IF HoldThatClick(ExitRect) THEN															BEGIN																ExitFlag := TRUE;																JumpLocation := CardProc;															END;													END;												JunkPart := FindControl(MyEvent.where, whichWindow, whichControl);												i := 1;												WHILE (i <= MaxConstants) & (CConstantText[i] <> '') DO													BEGIN														IF whichControl = ScrollConstant[i] THEN															BEGIN																WarningFlag := TRUE; {ECO 6: this line is new}																WhichConstant := i;																IF JunkPart = InThumb THEN																	BEGIN																		thePart := TrackControl(whichControl, MyEvent.where, NIL);																		JumpConstant;																	END																ELSE																	thePart := TrackControl(ScrollConstant[i], MyEvent.where, @ConstantScroll);															END;														i := i + 1;													END;											END;								END;							END;						OTHERWISE							BEGIN {Spoof the compiler}							END;					END;				END;		UNTIL ExitFlag | QuitGame;{ECO 6: new code chunk}		InitCursor;		IF NOT QuitGame & WarningFlag & NoWarningYet THEN			BEGIN				NoWarningYet := FALSE;				x := StopAlert(158, NIL);			END;		i := 1;		WHILE (i <= MaxConstants) & (CConstantText[i] <> '') DO			BEGIN				DisposeControl(ScrollConstant[i]);				i := i + 1;			END;		IF PScrollFlag THEN			ShowControl(PolicyScroll);	END;{************************************************************************}PROCEDURE ChangeSubsidy;{frozen}	VAR		k: Integer;		TempRect: Rect;		RealX: Real;	BEGIN		k := InversionIndex[ThisCard];		RealX := GetCtlValue(PolicyScroll);		SetRect(TempRect, 160, 105, 320, 119);		FillRect(TempRect, white);		TextFont(1);		TextSize(12);		MoveTo(164, 116);		MyFloatWrite(RealX);		DrawString('%');		SubsidyValue[k] := RealX;		TimeDelay(4); {ECO 4: inserted this line}	END;{************************************************************************}PROCEDURE ScrollSubsidy (theControl: ControlHandle; thisPart: Integer);{frozen}	VAR		delta: Integer;		OldValue: Integer;	BEGIN		CASE thisPart OF			inUpButton: 				delta := -1;			inDownButton: 				delta := 1;			inPageUp: 				delta := -10;			inPageDown: 				delta := 10;			OTHERWISE				delta := 0;		END;		IF thisPart <> 0 THEN			BEGIN				oldValue := GetCtlValue(theControl);				SetCtlValue(theControl, oldValue + delta);				IF GetCtlValue(theControl) <> oldValue THEN					ChangeSubsidy;			END;	END;{*****************************************************************}PROCEDURE ChangeTax;{frozen}	VAR		k: Integer;		TempRect: Rect;		RealX: Real;	BEGIN		k := InversionIndex[ThisCard];		RealX := (GetCtlValue(PolicyScroll) * 3.75 * InitialTaxValue[k] / 100) + InitialTaxValue[k] / 4;		SetRect(TempRect, 160, 105, 320, 119);		FillRect(TempRect, white);		TextFont(1);		TextSize(12);		MoveTo(164, 116);		MyFloatWrite(RealX);		DrawString(CardUnit[ThisCard]);		TaxValue[k] := RealX;		TimeDelay(4); {ECO 4: inserted this line}	END;{************************************************************************}PROCEDURE ScrollTax (theControl: ControlHandle; thisPart: Integer);{frozen}	VAR		delta: Integer;		OldValue: Integer;	BEGIN		CASE thisPart OF			inUpButton: 				delta := -1;			inDownButton: 				delta := 1;			inPageUp: 				delta := -10;			inPageDown: 				delta := 10;			OTHERWISE				delta := 0;		END;		IF thisPart <> 0 THEN			BEGIN				oldValue := GetCtlValue(theControl);				SetCtlValue(theControl, oldValue + delta);				IF GetCtlValue(theControl) <> oldValue THEN					ChangeTax;			END;	END;{*****************************************************************}PROCEDURE RunCard;{frozen}	VAR		i, j, x, y: Integer;		TempRect: Rect;		SubFlag: Boolean;		AbortFlag: Boolean;		BarValue: Real;		DelayTime: LongInt;		TempReal: Real;		InvIndex: Integer;		JunkPart: Integer;		MousePt: Point;	BEGIN		LoadCard;		DrawCard;{ECO 6: changed 8 to 3}		EnableItem(MenuArr[2], 3);		ExitFlag := FALSE;		REPEAT			SystemTask;			y := 26;			i := 1;			GetMouse(MousePt);			AbortFlag := FALSE;			WHILE (i <= MaxCauses) & (Cause[ThisCard, i] > 0) & NOT AbortFlag DO				BEGIN					SetRect(TempRect, BitMapWidth + 1, y - 9, 513, y + 3);					y := y + 12;					IF PtInRect(MousePt, TempRect) THEN						AbortFlag := TRUE;					i := i + 1;				END;			y := y + 28;			i := 1;			WHILE (i <= MaxCauses) & (Effect[ThisCard, i] > 0) & NOT AbortFlag DO				BEGIN					SetRect(TempRect, BitMapWidth + 1, y - 9, 513, y + 3);					y := y + 12;					IF PtInRect(MousePt, TempRect) THEN						AbortFlag := TRUE;					BEGIN					END;					i := i + 1;				END;			FOR i := 1 TO 10 DO				IF PtInRect(MousePt, BarRect[i]) THEN					AbortFlag := TRUE;			IF AbortFlag THEN				SetCursor(MaltaKreuz^^)			ELSE				InitCursor;			IF GetNextEvent(everyEvent, myEvent) THEN				BEGIN					TestForColor;					CASE myEvent.what OF						KeyDown: 							KeyHandler;						UpdateEvt: 							BEGIN								GetPort(SavePort);								whichWindow := WindowPtr(MyEvent.message);								SetPort(whichWindow);								BeginUpdate(whichWindow);								DrawCard;								EndUpdate(MainWind);								SetPort(SavePort);							END;						mouseDown: 							BEGIN								thePart := FindWindow(myEvent.where, whichWindow);								CASE thePart OF									InDrag: 										DoDrag;									InMenuBar: 										DoCommand(MenuSelect(MyEvent.where));									InSysWindow: 										SystemClick(MyEvent, whichWindow);									InContent: 										IF whichWindow <> FrontWindow THEN											SelectWindow(whichWindow)										ELSE											BEGIN												GlobalToLocal(MyEvent.where);												y := 26;												AbortFlag := FALSE;												i := 1;												WHILE (i <= MaxCauses) & (Cause[ThisCard, i] > 0) & NOT AbortFlag DO													BEGIN														SetRect(TempRect, BitMapWidth + 1, y - 9, 513, y + 3);														y := y + 12;														IF PtInRect(myEvent.where, TempRect) THEN															BEGIN																IF HoldThatClick(TempRect) THEN																	BEGIN																		ThisCard := Cause[ThisCard, i];{ECO 4: Big change in flow of control here, arising from addition of one line and deletion of two.}{LoadCard;}{DrawCard;}																		ExitFlag := TRUE; {ECO 4: this is the line addition.}																		AbortFlag := TRUE;																	END;															END;														i := i + 1;													END;												y := y + 28;												i := 1;												WHILE (i <= MaxCauses) & (Effect[ThisCard, i] > 0) & NOT AbortFlag DO													BEGIN														SetRect(TempRect, BitMapWidth + 1, y - 9, 513, y + 3);														y := y + 12;														IF PtInRect(myEvent.where, TempRect) THEN															BEGIN																IF HoldThatClick(TempRect) THEN																	BEGIN																		ThisCard := Effect[ThisCard, i];{ECO 4: Big change in flow of control here, arising from addition of one line and deletion of two.}{LoadCard;}{DrawCard;}																		ExitFlag := TRUE; {ECO 4: this is the line addition.}																		AbortFlag := TRUE;																	END;															END;														i := i + 1;													END;												IF (NOT ExitFlag) & (CardType[ThisCard] = TaxCard) THEN													BEGIN {test to see if there is a tax clickrect}														JunkPart := FindControl(MyEvent.where, whichWindow, whichControl);														IF whichControl = PolicyScroll THEN															BEGIN																IF JunkPart = InThumb THEN																	BEGIN																		thePart := TrackControl(whichControl, MyEvent.where, NIL);																		ChangeTax;																	END																ELSE																	thePart := TrackControl(PolicyScroll, MyEvent.where, @ScrollTax);																InvIndex := InversionIndex[ThisCard];																CASE InvIndex OF																	CFCTaxIndex: 																		TempReal := CardValue[CFCProduction];																	CoalTaxIndex: 																		TempReal := CardValue[CoalUse];																	OilTaxIndex: 																		TempReal := CardValue[OilUse];																	NaturalGasTaxIndex: 																		TempReal := CardValue[NaturalGasUse];																	NuclearTaxIndex: 																		TempReal := CardValue[NuclearUse];																	BeefTaxIndex: 																		TempReal := CardValue[BeefProduction];																	LoggingTaxIndex: 																		TempReal := CardValue[Logging];																	HeavyMetalTaxIndex: 																		TempReal := CardValue[HeavyMetalUse];																	FertilizerTaxIndex: 																		TempReal := CardValue[FertilizerUse];																	PesticideTaxIndex: 																		TempReal := CardValue[PesticideUse];																END; {of InverstionTemp CASE statement}																TempReal := TaxValue[InvIndex] * TempReal;																CardValue[ThisCard] := TempReal;																CardHistory[ThisCard, Turn] := TempReal;																CalcTreasury;																DrawBarChart;															END; {PolicyScroll IF}													END; {TaxCard IF}												IF NOT ExitFlag & (CardType[ThisCard] = SubsidyCard) & (ThisCard <> PropertyDamage%S) THEN													BEGIN {test to see if there is a Subsidy clickrect}														JunkPart := FindControl(MyEvent.where, whichWindow, whichControl);														IF whichControl = PolicyScroll THEN															BEGIN																IF JunkPart = InThumb THEN																	BEGIN																		thePart := TrackControl(whichControl, MyEvent.where, NIL);																		ChangeSubsidy;																	END																ELSE																	thePart := TrackControl(PolicyScroll, MyEvent.where, @ScrollSubsidy);																InvIndex := InversionIndex[ThisCard];																CalcTreasury;																CardValue[ThisCard] := SubsidyValue[InvIndex] * Treasury / 100;																CardHistory[ThisCard, Turn] := CardValue[ThisCard];																DrawBarChart;															END;													END;												FOR i := 1 TO 10 DO {ECO 2: note new upper limit on loop}													IF PtInRect(myEvent.where, BarRect[i]) THEN														BEGIN {user clicked on a bar from the barchart; replace a value for him}{ECO 2: I eliminated the need for the CASE statement that had been here.}															DrawNumericValue(i);															REPEAT																InvertRect(BarRect[i]);{ECO 4: Made some code into PROCEDURE TimeDelay}																TimeDelay(20);																InvertRect(BarRect[i]);																TimeDelay(20);															UNTIL NOT StillDown;															DrawNumericValue(Turn);														END;											END;									OTHERWISE								END; {thePart CASE}							END; {mousedown instance}						OTHERWISE					END;				END; {GetNextEvent IF}		UNTIL ExitFlag;{ECO 6: changed menu item number from 8 to 3}		DisableItem(MenuArr[2], 3);{ECO 4: Moved this IF-statement from LoadCard in Globals.p, added screen-update-defeat}		IF PScrollFlag THEN			BEGIN				DisposeControl(PolicyScroll);				SetRect(TempRect, 0, 0, 512, 342);				ValidRect(TempRect); {turn off the damn update mechanism, thank you!}				PScrollFlag := FALSE;			END;	END;{*****************************************************************}PROCEDURE RunStack;{frozen}	BEGIN		QuitGame := FALSE;		JumpLocation := EarthProc;		REPEAT			InitCursor;			CASE JumpLocation OF				EarthProc: 					RunEarth;				PointProc: 					RunPoints;				MoneyProc: 					RunMoney;				CardProc: 					RunCard;				FormulaProc: 					RunFormula;				TreeProc: 					RunTree;			END;		UNTIL QuitGame;	END;{*****************************************************************}END.