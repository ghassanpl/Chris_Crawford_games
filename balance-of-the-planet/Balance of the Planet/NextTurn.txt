UNIT NextTurn;INTERFACEUSES	Globals, Initialization;{ECO 6: Note addition of arguement YearsPerTurn}PROCEDURE NextTurn (YearsPerTurn: Integer);IMPLEMENTATION{*****************************************************************}PROCEDURE EndGame;{frozen}	CONST		PointCount = 17;	VAR		i, j, k, y: Integer;		Index: Integer;		TempStr: Str255;		SortedPoints: ARRAY[1..PointCount] OF Real;		GoodOrBad: ARRAY[1..PointCount] OF Boolean;		Inversion: ARRAY[1..PointCount] OF Integer;		Improvement: Real;{-------------------------------------------------------------------------------------------}	FUNCTION StringIndex (i: Integer): Integer;		BEGIN			CASE Inversion[i] OF				BiodiversityPoints: 					StringIndex := 101;				FallPoints: 					StringIndex := 102;				FloodDeathPoints: 					StringIndex := 103;				ForestLifePoints: 					StringIndex := 104;				HeavyMetalPoints: 					StringIndex := 105;				InundationPoints: 					StringIndex := 106;				LakeLifePoints: 					StringIndex := 107;				LandAbusePoints: 					StringIndex := 108;				LungDiseasePts: 					StringIndex := 109;				MarineLifePoints: 					StringIndex := 110;				PesticideDeathPts: 					StringIndex := 111;				QualityPoints: 					StringIndex := 112;				RadWastePoints: 					StringIndex := 113;				RadiationPoints: 					StringIndex := 114;				SkinCancerPoints: 					StringIndex := 115;				StarvationPoints: 					StringIndex := 116;				SustainabilityPts: 					StringIndex := 117;			END;		END;{-------------------------------------------------------------------------------------------}	PROCEDURE DumbProcName (NegateFlag: Boolean);{frozen}		VAR			i, Adder: Integer;		BEGIN			IF NegateFlag THEN				Adder := 0			ELSE				Adder := 3;			i := 1;			WHILE (i < PointCount - 4) & (SortedPoints[i] > 100) DO				BEGIN					IF (NegateFlag OR GoodOrBad[i]) AND NOT (NegateFlag AND GoodOrBad[i]) THEN						BEGIN							IF SortedPoints[i] > 10000 THEN								Index := 1							ELSE IF SortedPoints[i] > 1000 THEN								Index := 2							ELSE								Index := 3;							GetIndString(TempStr, StringIndex(i), Index + Adder);							MoveTo(20, y);							DrawString(TempStr);							y := y + 15;						END;					i := i + 1;				END;		END;{-------------------------------------------------------------------------------------------}	PROCEDURE DrawTheEnd;{frozen}		BEGIN			IF Points > 0 THEN				FillRect(MainWind^.portRect, white)			ELSE				FillRect(MainWind^.portRect, black);			TextFont(2);			TextSize(18);			TempStr := 'The game is over; your term has expired.';			MoveTo(256 - (StringWidth(TempStr) DIV 2), 30);			DrawString(TempStr);			TextSize(12);			TextFont(1);			y := 56;			DumbProcName((Points <= 0));			y := y + 15;			MoveTo(20, y);			TextFace([bold]);			DrawString('On the other hand:');			TextFace([]);			y := y + 15;			DumbProcName((Points > 0));			TextFont(2);			TextSize(18);			NumToString(Trunc(Points), TempStr);			TempStr := Concat('Your final score is ', TempStr, ' points.');			MoveTo(256 - (StringWidth(TempStr) DIV 2), 300);			DrawString(TempStr);			TextFont(0);			TextSize(12);			TempStr := 'Click mouse to continue';			MoveTo(256 - (StringWidth(TempStr) DIV 2), 320);			DrawString(TempStr);		END;{-------------------------------------------------------------------------------------------}	BEGIN{ECO 6: changed 3 to 4}		DisableItem(MenuArr[2], 4);		FOR i := 1 TO PointCount DO			SortedPoints[i] := 0;		Points := 0;		FOR i := 1 TO MaxNoCards DO			BEGIN				IF CardType[i] = LifePtsCard THEN					BEGIN						Points := Points + CardValue[i];						Improvement := Abs(CardValue[i] - CardHistory[i, 1]);						j := 1;						WHILE (j <= PointCount) & (Improvement < SortedPoints[j]) DO							j := j + 1;						FOR k := PointCount DOWNTO j + 1 DO							BEGIN								SortedPoints[k] := SortedPoints[k - 1];								Inversion[k] := Inversion[k - 1];								GoodOrBad[k] := GoodOrBad[k - 1];							END;						SortedPoints[j] := Improvement;						Inversion[j] := i;						GoodOrBad[j] := CardValue[i] > CardHistory[i, 1];					END;				IF CardType[i] = DeathPtsCard THEN					BEGIN						Points := Points - CardValue[i];						Improvement := Abs(CardHistory[i, 1] - CardValue[i]);						j := 1;						WHILE (j <= PointCount) & (Improvement < SortedPoints[j]) DO							j := j + 1;						FOR k := PointCount DOWNTO j + 1 DO							BEGIN								SortedPoints[k] := SortedPoints[k - 1];								Inversion[k] := Inversion[k - 1];								GoodOrBad[k] := GoodOrBad[k - 1];							END;						SortedPoints[j] := Improvement;						Inversion[j] := i;						GoodOrBad[j] := CardValue[i] < CardHistory[i, 1];					END;			END;		TextMode(srcXOr);		ExitFlag := FALSE;		REPEAT			SystemTask;			IF GetNextEvent(everyEvent, MyEvent) THEN				BEGIN					CASE MyEvent.what OF						UpdateEvt: 							BEGIN								GetPort(SavePort);								whichWindow := WindowPtr(MyEvent.message);								SetPort(whichWindow);								BeginUpdate(whichWindow);								DrawTheEnd;								EndUpdate(MainWind);								SetPort(SavePort);							END;						mouseDown: 							ExitFlag := TRUE;						OTHERWISE {isn't it unsettling to see the programmer defeating Pascal's paternalism?}					END;				END; {GetNextEvent IF}		UNTIL ExitFlag;	END;{*****************************************************************}PROCEDURE NextTurn (YearsPerTurn: Integer);{ECO 4: I mistakenly marked this procedure as frozen. Not so! Liquid until Feb 1!}{liquid}	VAR		i, j: Integer;		SumCost: Real;		SumUse: Real;		OldGlobalTemperature: Real;		TempReal: Real;		OldGGP: Real;	BEGIN		SetCursor(WatchCursr^^);		FOR i := 1 TO MaxNoCards DO			BEGIN				IF (CardType[i] = TaxCard) THEN					InitialTaxValue[InversionIndex[i]] := TaxValue[InversionIndex[i]];				IF (CardType[i] = SubsidyCard) THEN					InitialSubsidyValue[InversionIndex[i]] := SubsidyValue[InversionIndex[i]];			END;		FOR j := 1 TO YearsPerTurn DO			BEGIN				Year := Year + 1;				CardValue[CFCTax] := TaxValue[CFCTaxIndex] * CardValue[CFCProduction];				CardValue[CoalTax] := TaxValue[CoalTaxIndex] * CardValue[CoalUse];				CardValue[OilTax] := TaxValue[OilTaxIndex] * CardValue[OilUse];				CardValue[NaturalGasTax] := TaxValue[NaturalGasTaxIndex] * CardValue[NaturalGasUse];				CardValue[NuclearTax] := TaxValue[NuclearTaxIndex] * CardValue[NuclearUse];				CardValue[BeefTax] := TaxValue[BeefTaxIndex] * CardValue[BeefProduction];				CardValue[LoggingTax] := TaxValue[LoggingTaxIndex] * CardValue[Logging];				CardValue[HeavyMetalTax] := TaxValue[HeavyMetalTaxIndex] * CardValue[HeavyMetalUse];				CardValue[FertilizerTax] := TaxValue[FertilizerTaxIndex] * CardValue[FertilizerUse];				CardValue[PesticideTax] := TaxValue[PesticideTaxIndex] * CardValue[PesticideUse];				CardValue[PropertyDamage%S] := CardConstant[PropertyDamage%S, 1] * CardValue[SulfurDioxide] + CardConstant[PropertyDamage%S, 2] * CardValue[NitrousDioxide];				CalcTreasury;				TempReal := (CardValue[BioResearch%S] + 1) * (CardValue[BasicResearch%S] + 1);				CardValue[Biotechnology] := CardValue[Biotechnology] + CardConstant[Biotechnology, 1] * ln(TempReal) / 2.3;				TempReal := (CardValue[CoalResearch%S] + 1) * (CardValue[BasicResearch%S] + 1);				CardValue[CoalTechnology] := CardValue[CoalTechnology] + CardConstant[CoalTechnology, 1] * ln(TempReal) / 2.3;				TempReal := (CardValue[NuclearResearch%S] + 1) * (CardValue[BasicResearch%S] + 1);				CardValue[NuclearTechnology] := CardValue[NuclearTechnology] + CardConstant[NuclearTechnology, 1] * ln(TempReal) / 2.3;				TempReal := (CardValue[OilResearch%S] + 1) * (CardValue[BasicResearch%S] + 1);				CardValue[OilTechnology] := CardValue[OilTechnology] + CardConstant[OilTechnology, 1] * ln(TempReal) / 2.3;				TempReal := (CardValue[SolarResearch%S] + 1) * (CardValue[BasicResearch%S] + 1);				CardValue[SolarTechnology] := CardValue[SolarTechnology] + CardConstant[SolarTechnology, 1] * ln(TempReal) / 2.3;				CardValue[CFCProduction] := CardConstant[CFCProduction, 1] * CardValue[MaterialsDemand] / (CardConstant[CFCProduction, 2] + CardConstant[CFCProduction, 3] * TaxValue[CFCTaxIndex]);				CardValue[CoalUse] := CardConstant[CoalUse, 1] * CardValue[EnergyDemand] * CardValue[AveEnergyPrice] / (CardValue[CoalPrice] + TaxValue[CoalTaxIndex]);				CardValue[OilUse] := CardConstant[OilUse, 1] * CardValue[EnergyDemand] * CardValue[AveEnergyPrice] / (CardValue[OilPrice] + TaxValue[OilTaxIndex]);				CardValue[NaturalGasUse] := CardConstant[NaturalGasUse, 1] * CardValue[EnergyDemand] * CardValue[AveEnergyPrice] / (CardValue[NaturalGasPrice] + TaxValue[NaturalGasTaxIndex]);				CardValue[NuclearUse] := CardConstant[NuclearUse, 1] * CardValue[EnergyDemand] * CardValue[AveEnergyPrice] / (CardValue[NuclearPrice] + TaxValue[NuclearTaxIndex]);				CardValue[BeefProduction] := CardConstant[BeefProduction, 1] * CardValue[Grasslands] / (CardConstant[BeefProduction, 2] + CardConstant[BeefProduction, 3] * TaxValue[BeefTaxIndex]);				CardValue[Logging] := (CardConstant[Logging, 1] * CardValue[MaterialsDemand] / (CardConstant[Logging, 2] + CardConstant[Logging, 3] * TaxValue[LoggingTaxIndex])) * (1 - 0.3 * CardValue[RecycledPaper]);				IF CardValue[Logging] < 0 THEN					CardValue[Logging] := 0;				CardValue[HeavyMetalUse] := CardConstant[HeavyMetalUse, 1] * CardValue[MaterialsDemand] / (CardValue[HeavyMetalPrice] + CardConstant[HeavyMetalUse, 2] * TaxValue[HeavyMetalTaxIndex]);				CardValue[FertilizerUse] := (CardValue[IndustrialOutput] * CardConstant[FertilizerUse, 1]) / (CardConstant[FertilizerUse, 2] + CardConstant[FertilizerUse, 3] * TaxValue[FertilizerTaxIndex]);				CardValue[PesticideUse] := CardConstant[PesticideUse, 1] * CardValue[IndustrialOutput] / (CardConstant[PesticideUse, 2] + CardConstant[PesticideUse, 3] * TaxValue[PesticideTaxIndex]);				FOR i := 1 TO 8 DO					BEGIN						CardValue[SolarEnergyUse] := (CardConstant[SolarEnergyUse, 1] * CardValue[EnergyDemand] * CardValue[AveEnergyPrice] + CardValue[SolarEnergy%S]) / CardValue[SolarEnergyPrice];						CardValue[DamUse] := (CardValue[EnergyDemand] * CardValue[AveEnergyPrice] * CardConstant[DamUse, 1] + CardValue[Dam%S]) / CardValue[DamPrice];						CardValue[SolarEnergyPrice] := (CardValue[SolarEnergyPrice] + (CardValue[SolarEnergyUse] / (CardConstant[SolarEnergyPrice, 1] * CardValue[SolarTechnology]))) / 2;						IF CardValue[SolarEnergyPrice] < 1 THEN							CardValue[SolarEnergyPrice] := 1;						CardValue[DamPrice] := (CardValue[DamPrice] + CardValue[DamUse] / CardConstant[DamPrice, 1]) / 2;						IF CardValue[DamPrice] < 1 THEN							CardValue[DamPrice] := 1;					END;				CardValue[FallsFromRoofs] := CardConstant[FallsFromRoofs, 1] * CardValue[SolarEnergyUse];				CardValue[FallPoints] := CardConstant[FallPoints, 1] * CardValue[FallsFromRoofs];				CardValue[RenewableEnergy] := CardValue[SolarEnergyUse] + CardValue[DamUse];				CardValue[FuelwoodUse] := CardValue[Population] * CardConstant[FuelwoodUse, 1] - CardConstant[FuelwoodUse, 2] * CardValue[WoodStove%S];				IF CardValue[FuelwoodUse] < 0 THEN					CardValue[FuelwoodUse] := 0;				CardValue[ForestClearing] := CardConstant[ForestClearing, 1] * CardValue[Starvation] - CardValue[DebtforNature%S] / CardConstant[ForestClearing, 2];				IF CardValue[ForestClearing] < 0 THEN					CardValue[ForestClearing] := 0;				CardValue[BirthRate] := CardConstant[BirthRate, 1] / (1 + CardConstant[BirthRate, 2] * Sqrt(CardValue[FamilyPlanning%S]) + CardValue[QualityofLife]);				IF CardValue[BirthRate] > CardConstant[BirthRate, 1] THEN					CardValue[BirthRate] := CardConstant[BirthRate, 1];				CardValue[RecycledAluminum] := CardConstant[RecycledAluminum, 1] * CardValue[RecyclingCenter%S];				CardValue[RecycledPaper] := 1 - exp(-CardConstant[RecycledPaper, 1] * CardValue[RecyclingCenter%S]);				CardValue[TroposphericCFCs] := CardValue[TroposphericCFCs] * (1 - CardConstant[TroposphericCFCs, 1]) + CardValue[CFCProduction];				IF CardValue[TroposphericCFCs] < 0 THEN					CardValue[TroposphericCFCs] := 0;				CardValue[StratosphericCFC] := CardConstant[StratosphericCFC, 1] * CardValue[TroposphericCFCs];				IF CardValue[StratosphericCFC] < 0 THEN					CardValue[StratosphericCFC] := 0;				CardValue[Ozone] := CardConstant[Ozone, 1] - CardConstant[Ozone, 2] * CardValue[StratosphericCFC];				IF CardValue[Ozone] < 1 THEN					CardValue[Ozone] := 1;				CardValue[UV] := CardConstant[UV, 1] / (CardConstant[UV, 2] * CardValue[Ozone]);				IF CardValue[UV] > CardConstant[UV, 1] THEN					CardValue[UV] := CardConstant[UV, 1];				CardValue[SkinCancerDeaths] := CardConstant[SkinCancerDeaths, 1] * CardValue[UV];				CardValue[SkinCancerPoints] := CardConstant[SkinCancerPoints, 1] * CardValue[SkinCancerDeaths];				CardValue[Phytoplankton] := CardConstant[Phytoplankton, 1] * (1 - CardConstant[Phytoplankton, 2] * CardValue[UV]);				IF CardValue[Phytoplankton] < 0 THEN					CardValue[Phytoplankton] := 0;				CardValue[RiparianHabitats] := CardConstant[RiparianHabitats, 1] - CardConstant[RiparianHabitats, 2] * CardValue[DamUse];				IF CardValue[RiparianHabitats] < 0 THEN					CardValue[RiparianHabitats] := 0;				CardValue[TotalCoalUse] := CardValue[TotalCoalUse] + CardValue[CoalUse];				CardValue[TotalNatGasUse] := CardValue[TotalNatGasUse] + CardValue[NaturalGasUse];				CardValue[TotalNuclearUse] := CardValue[TotalNuclearUse] + CardValue[NuclearUse];				CardValue[TotalOilUse] := CardValue[TotalOilUse] + CardValue[OilUse];				FOR i := 1 TO 8 DO					BEGIN						CardValue[CoalPrice] := (CardValue[CoalPrice] + CardConstant[CoalPrice, 1] * CardValue[CoalUse] / CardValue[CoalSupply]) / 2;						CardValue[CoalSupply] := CardConstant[CoalSupply, 1] * CardValue[CoalPrice] - CardValue[TotalCoalUse];						IF CardValue[CoalSupply] < CardValue[CoalUse] THEN							CardValue[CoalSupply] := CardValue[CoalUse];						CardValue[NaturalGasPrice] := (CardValue[NaturalGasPrice] + CardConstant[NaturalGasPrice, 1] * CardValue[NaturalGasUse] / CardValue[NaturalGasSupply]) / 2;						CardValue[NaturalGasSupply] := CardConstant[NaturalGasSupply, 1] * CardValue[NaturalGasPrice] - CardValue[TotalNatGasUse];						IF CardValue[NaturalGasSupply] < CardValue[NaturalGasUse] THEN							CardValue[NaturalGasSupply] := CardValue[NaturalGasUse];						CardValue[NuclearPrice] := (CardValue[NuclearPrice] + CardConstant[NuclearPrice, 1] * CardValue[NuclearUse] / CardValue[NuclearSupply]) / 2;						CardValue[NuclearSupply] := CardConstant[NuclearSupply, 1] * CardValue[NuclearPrice] - CardValue[TotalNuclearUse];						IF CardValue[NuclearSupply] < CardValue[NuclearUse] THEN							CardValue[NuclearSupply] := CardValue[NuclearUse];						CardValue[OilPrice] := (CardValue[OilPrice] + CardConstant[OilPrice, 1] * CardValue[OilUse] / CardValue[OilSupply]) / 2;						CardValue[OilSupply] := CardConstant[OilSupply, 1] * CardValue[OilPrice] - CardValue[TotalOilUse];						IF CardValue[OilSupply] < CardValue[OilUse] THEN							CardValue[OilSupply] := CardValue[OilUse];					END;				CardValue[StripMining] := CardConstant[StripMining, 1] * CardValue[CoalUse];				CardValue[SulfurDioxide] := CardConstant[SulfurDioxide, 1] * CardValue[CoalUse] / CardValue[CoalTechnology];				CardValue[NitrousDioxide] := (CardConstant[NitrousDioxide, 1] * CardValue[CoalUse] / CardValue[CoalTechnology]) + CardConstant[NitrousDioxide, 2] * CardValue[OilUse] / CardValue[OilTechnology];				CardValue[NonrenewEnergy] := CardValue[CoalUse] + CardValue[OilUse] + CardValue[NaturalGasUse] + CardValue[NuclearUse];				CardValue[OilSpills] := CardConstant[OilSpills, 1] * CardValue[OilUse];				CardValue[LungDiseaseDeaths] := CardConstant[LungDiseaseDeaths, 1] * CardValue[SulfurDioxide] + CardConstant[LungDiseaseDeaths, 2] * CardValue[NitrousDioxide];				CardValue[LungDiseasePts] := CardConstant[LungDiseasePts, 1] * CardValue[LungDiseaseDeaths];				CardValue[AcidRain] := CardValue[SulfurDioxide] + CardValue[NitrousDioxide];				SumCost := (CardValue[CoalPrice] + TaxValue[CoalTaxIndex]) * CardValue[CoalUse];				SumCost := SumCost + CardValue[DamPrice] * CardValue[DamUse] - CardValue[Dam%S];				SumCost := SumCost + (CardValue[NaturalGasPrice] + TaxValue[NaturalGasTaxIndex]) * CardValue[NaturalGasUse];				SumCost := SumCost + (CardValue[NuclearPrice] + TaxValue[NuclearTaxIndex]) * CardValue[NuclearUse];				SumCost := SumCost + (CardValue[OilPrice] + TaxValue[OilTaxIndex]) * CardValue[OilUse];				SumCost := SumCost + CardValue[SolarEnergyPrice] * CardValue[SolarEnergyUse] - CardValue[SolarEnergy%S];				SumUse := CardValue[CoalUse] + CardValue[DamUse] + CardValue[NaturalGasUse];				SumUse := SumUse + CardValue[NuclearUse] + CardValue[OilUse] + CardValue[SolarEnergyUse];				CardValue[AveEnergyPrice] := SumCost / SumUse;				IF CardValue[AveEnergyPrice] < 1 THEN					CardValue[AveEnergyPrice] := 1;				CardValue[LakeAcidity] := (CardValue[LakeAcidity] * CardConstant[LakeAcidity, 1] + CardValue[AcidRain]) * CardConstant[LakeAcidity, 2] / CardConstant[LakeAcidity, 1];				CardValue[LakeHabitats] := CardConstant[LakeHabitats, 1] / ((CardConstant[LakeHabitats, 2] + CardValue[LakeAcidity]) * CardConstant[LakeHabitats, 3]);				CardValue[LakeLifePoints] := CardConstant[LakeLifePoints, 1] * CardValue[LakeHabitats];				CardValue[RadWaste] := CardValue[RadWaste] + CardConstant[RadWaste, 1] * CardValue[NuclearUse] / CardValue[NuclearTechnology];				CardValue[RadWastePoints] := CardConstant[RadWastePoints, 1] * CardValue[RadWaste];				CardValue[Radiation] := CardConstant[Radiation, 1] * CardValue[NuclearUse] / CardValue[NuclearTechnology];				CardValue[NuclearAccidents] := CardConstant[NuclearAccidents, 1] * CardValue[NuclearUse] / CardValue[NuclearTechnology];				CardValue[RadiationCancer] := CardConstant[RadiationCancer, 1] * CardValue[Radiation] + CardConstant[RadiationCancer, 2] * CardValue[NuclearAccidents];				CardValue[RadiationPoints] := CardConstant[RadiationPoints, 1] * CardValue[RadiationCancer];				CardValue[WaterPollution] := CardConstant[WaterPollution, 1] * CardValue[HeavyMetalUse] + CardConstant[WaterPollution, 2] * CardValue[PesticideUse] + CardConstant[WaterPollution, 3] * CardValue[FertilizerUse];				CardValue[GroundwaterUse] := CardConstant[GroundwaterUse, 1] * (CardValue[GroundwaterSupply] - CardConstant[GroundwaterUse, 2] * CardValue[LandAbuse]) / Sqrt(CardValue[AveEnergyPrice]);				IF CardValue[GroundwaterUse] < 0 THEN					CardValue[GroundwaterUse] := 0;				CardValue[GroundwaterSupply] := CardValue[GroundwaterSupply] - CardValue[GroundwaterUse];				IF CardValue[GroundwaterSupply] < 0 THEN					CardValue[GroundwaterSupply] := 0;				CardValue[ReservoirCapacity] := CardConstant[ReservoirCapacity, 1] * CardValue[DamUse];				CardValue[WaterSupply] := CardValue[GroundwaterUse] + CardValue[ReservoirCapacity] - CardValue[WaterPollution];				IF CardValue[WaterSupply] < 0 THEN					CardValue[WaterSupply] := 0;				CardValue[MarineLife] := CardConstant[MarineLife, 1] * CardValue[Phytoplankton] - CardValue[Seafood] - CardConstant[MarineLife, 2] * CardValue[PesticideUse] - CardConstant[MarineLife, 3] * CardValue[OilSpills];				IF CardValue[MarineLife] < 0 THEN					CardValue[MarineLife] := 0;				CardValue[MarineLifePoints] := CardConstant[MarineLifePoints, 1] * CardValue[MarineLife];				CardValue[Seafood] := CardConstant[Seafood, 1] * CardValue[MarineLife];				CardValue[Methane] := CardValue[Methane] * (1 - CardConstant[Methane, 1]) + CardConstant[Methane, 2] * CardValue[BeefProduction] + CardConstant[Methane, 3] * CardValue[AcidRain];				IF CardValue[Methane] < 0 THEN					CardValue[Methane] := 0;				CardValue[EnergyConservation] := CardConstant[EnergyConservation, 1] * sqrt(CardValue[AveEnergyPrice]) + CardConstant[EnergyConservation, 2] * CardValue[RecycledAluminum];				CardValue[NetEnergy] := CardValue[EnergyConservation] + CardValue[RenewableEnergy] + CardValue[NonrenewEnergy];				CardValue[Sustainability] := CardValue[RenewableEnergy] * (4 - CardValue[BirthRate]) / (CardValue[RenewableEnergy] + CardValue[NonrenewEnergy]);				IF CardValue[Sustainability] < 0 THEN					CardValue[Sustainability] := 0;				CardValue[SustainabilityPts] := CardConstant[SustainabilityPts, 1] * CardValue[Sustainability];				CardValue[Overgrazing] := CardConstant[Overgrazing, 1] * CardValue[Starvation];				CardValue[Desertification] := (CardValue[FuelwoodUse] - CardConstant[Desertification, 1]) * CardConstant[Desertification, 2] + CardValue[Overgrazing];				IF CardValue[Desertification] < 0 THEN					CardValue[Desertification] := 0;				CardValue[SoilErosion] := CardValue[Desertification] + CardValue[ForestClearing];				CardValue[Farmland] := CardValue[Farmland] + CardConstant[Farmland, 1] * CardValue[ForestClearing];				IF CardValue[Farmland] < 0 THEN					CardValue[Farmland] := 0;				CardValue[ForestLand] := CardValue[ForestLand] - CardValue[Logging] - CardConstant[ForestLand, 1] * CardValue[FuelwoodUse] - CardValue[ForestClearing] - CardConstant[ForestLand, 2] * CardValue[AcidRain];				IF CardValue[ForestLand] < 0 THEN					CardValue[ForestLand] := 0;				CardValue[ForestHabitats] := CardConstant[ForestHabitats, 1] * Sqrt(CardValue[ForestLand]);				CardValue[ForestLifePoints] := CardConstant[ForestLifePoints, 1] * CardValue[ForestHabitats];				CardValue[CarbonDioxide] := CardValue[CarbonDioxide] + (CardConstant[CarbonDioxide, 1] * (CardValue[CoalUse] + CardValue[NaturalGasUse] + CardValue[OilUse]) + CardConstant[CarbonDioxide, 2] * CardValue[ForestClearing]);				CardValue[FloodDeaths] := CardConstant[FloodDeaths, 1] * CardValue[SoilErosion] / CardValue[DamUse];				CardValue[FloodDeathPoints] := CardConstant[FloodDeathPoints, 1] * CardValue[FloodDeaths];				CardValue[HeavyMetalDeaths] := CardConstant[HeavyMetalDeaths, 1] * CardValue[HeavyMetalUse];				CardValue[HeavyMetalPoints] := CardConstant[HeavyMetalPoints, 1] * CardValue[HeavyMetalDeaths];				CardValue[TotHeavyMetUse] := CardValue[TotHeavyMetUse] + CardValue[HeavyMetalUse];				FOR i := 1 TO 8 DO					BEGIN						CardValue[HeavyMetalPrice] := (CardValue[HeavyMetalPrice] + CardConstant[HeavyMetalPrice, 1] * CardValue[HeavyMetalUse] / CardValue[HeavyMetalSupply]) / 2;						CardValue[HeavyMetalSupply] := CardConstant[HeavyMetalSupply, 1] * CardValue[HeavyMetalPrice] - CardValue[TotHeavyMetUse];						IF CardValue[HeavyMetalSupply] < 1 THEN							CardValue[HeavyMetalSupply] := 1;					END;				CardValue[IndustrialInput] := CardValue[NetEnergy] * sqrt(CardValue[GlobalGenePool]) * (CardValue[HeavyMetalUse] + CardValue[CFCProduction]);				CardValue[DrinkingWater] := CardConstant[DrinkingWater, 1] * CardValue[WaterSupply];				OldGlobalTemperature := CardValue[GlobalTemperature];				CardValue[GlobalTemperature] := CardConstant[GlobalTemperature, 1] + CardConstant[GlobalTemperature, 2] * CardValue[StratosphericCFC] + CardConstant[GlobalTemperature, 3] * CardValue[Methane] + CardConstant[GlobalTemperature, 4] * CardValue[CarbonDioxide];				CardValue[SeaLevel] := CardConstant[SeaLevel, 2] * (CardValue[GlobalTemperature] - CardConstant[SeaLevel, 1]);				IF CardValue[SeaLevel] < 0 THEN					CardValue[SeaLevel] := 0;				CardValue[InundationPoints] := CardConstant[InundationPoints, 1] * CardValue[SeaLevel];				CardValue[PesticideDeaths] := CardConstant[PesticideDeaths, 1] * CardValue[PesticideUse];				CardValue[PesticideDeathPts] := CardConstant[PesticideDeathPts, 1] * CardValue[PesticideDeaths];				CardValue[Population] := (CardValue[Population] * (1 + CardValue[BirthRate] / 100)) - CardValue[Starvation];				IF CardValue[Population] < 0 THEN					CardValue[Population] := 0;				CardValue[GlobalGenePool] := CardValue[ForestHabitats] + CardConstant[GlobalGenePool, 1] * CardValue[MarineLife] + CardValue[RiparianHabitats] + CardValue[LakeHabitats];				CardValue[BiodiversityPoints] := CardConstant[BiodiversityPoints, 1] * CardValue[GlobalGenePool];				CardValue[CropStrains] := CardValue[Biotechnology] * CardValue[GlobalGenePool] * CardConstant[CropStrains, 1];				CardValue[CropTechnology] := CardConstant[CropTechnology, 1] * CardValue[CropStrains] + CardConstant[CropTechnology, 2] * CardValue[PesticideUse] + CardConstant[CropTechnology, 3] * CardValue[FertilizerUse];				CardValue[Medicines] := CardValue[Biotechnology] * CardValue[GlobalGenePool];				CardValue[CropYields] := CardConstant[CropYields, 1] * CardValue[CropTechnology] + CardConstant[CropYields, 2] * CardValue[WaterSupply] - CardConstant[CropYields, 3] * CardValue[UV];				IF CardValue[CropYields] < 1e-1 THEN					CardValue[CropYields] := 1e-1;				CardValue[Crops] := CardValue[CropYields] * CardValue[Farmland] - CardConstant[Crops, 1] * CardValue[BeefProduction];				IF CardValue[Crops] < 0 THEN					CardValue[Crops] := 0;				CardValue[FoodSupply] := CardValue[Seafood] + CardValue[BeefProduction] + CardValue[Crops];				CardValue[Starvation] := (CardConstant[Starvation, 1] - CardValue[FoodSupply] / CardValue[Population]) * CardConstant[Starvation, 2] * CardValue[Population];				IF CardValue[Starvation] < 0 THEN					CardValue[Starvation] := 0;				CardValue[StarvationPoints] := CardConstant[StarvationPoints, 1] * CardValue[Starvation];				CardValue[Grasslands] := CardValue[Grasslands] - CardValue[Overgrazing];				IF CardValue[Grasslands] < 0 THEN					CardValue[Grasslands] := 0;				CardValue[IndustrialOutput] := CardValue[IndustrialInput];				CardValue[ConsumerGoods] := CardConstant[ConsumerGoods, 1] * CardValue[IndustrialOutput];				CardValue[Housing] := CardConstant[Housing, 1] * CardValue[Logging] + CardConstant[Housing, 2] * CardValue[IndustrialOutput];				OldGGP := CardValue[GrossGlobalProduct];				CardValue[GrossGlobalProduct] := CardConstant[GrossGlobalProduct, 1] * CardValue[IndustrialOutput];				CardValue[Garbage] := CardConstant[Garbage, 1] * CardValue[GrossGlobalProduct] - (CardValue[RecycledPaper] * (CardValue[Logging] / 3));				IF CardValue[Garbage] < 0 THEN					CardValue[Garbage] := 0;				CardValue[EnergyDemand] := 1.01 * CardValue[EnergyDemand];				CardValue[MaterialsDemand] := 1.01 * CardValue[MaterialsDemand];				CardValue[LandAbuse] := CardValue[StripMining] + CardConstant[LandAbuse, 1] * CardValue[Garbage];				CardValue[LandAbusePoints] := CardConstant[LandAbusePoints, 1] * CardValue[LandAbuse];				CardValue[NorthernLifestyle] := CardConstant[NorthernLifestyle, 1] * CardValue[Medicines] + CardConstant[NorthernLifestyle, 2] * CardValue[BeefProduction] + CardConstant[NorthernLifestyle, 3] * CardValue[ConsumerGoods] + CardConstant[NorthernLifestyle, 4] * CardValue[NetEnergy];				CardValue[SouthernLifestyle] := CardConstant[SouthernLifestyle, 1] * CardValue[Housing] + CardConstant[SouthernLifestyle, 2] * CardValue[DrinkingWater] + CardConstant[SouthernLifestyle, 3] * CardValue[FoodSupply];				CardValue[QualityofLife] := (CardConstant[QualityofLife, 1] * CardValue[NorthernLifestyle] + CardConstant[QualityofLife, 2] * CardValue[SouthernLifestyle]) / CardValue[Population];				IF CardValue[QualityofLife] < 0 THEN					CardValue[QualityofLife] := 0;				CardValue[QualityPoints] := CardConstant[QualityPoints, 1] * CardValue[QualityofLife];			END; {of j-loop for YearsPerTurn}		InitCursor;{ECO 6: minor change here, not significant to IBM port}		IF Turn > 0 THEN			InvalRect(MainWind^.portrect); {force screen update; on IBM you will need a more direct approach}{ECO 6: This is a new chunk of code}		LastPoints := Points;		Points := 0;		FOR i := 1 TO MaxNoCards DO			BEGIN				IF CardType[i] = LifePtsCard THEN					Points := Points + CardValue[i];				IF CardType[i] = DeathPtsCard THEN					Points := Points - CardValue[i];			END; {i-loop}		IF Turn = 0 THEN			LastPoints := Points; {kluge! kluge!}		Turn := Turn + 1;		FOR i := 1 TO MaxNoCards DO			CardHistory[i, Turn] := CardValue[i];		IF Turn = 10 THEN			EndGame;	END;{*****************************************************************}END.