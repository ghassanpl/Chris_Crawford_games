{}{	File:		Speech.p}{}{	Copyright:	© 1993-1994 by Apple Computer, Inc., all rights reserved.}{}UNIT Speech;INTERFACE	CONST		gestaltSpeechAttr = 'ttsc';		{ Gestalt Manager selector for Speech Attributes }		gestaltSpeechMgrPresent = 0;	{ Gestalt bit which indicates that Speech Manager exists }		kTextToSpeechSynthType = 'ttsc';	{ Text-to-Speech Synthesizer component type 	}		kTextToSpeechVoiceType = 'ttvd';	{ Text-to-Speech Voice resource type 			}		kTextToSpeechVoiceFileType = 'ttvf';	{ Text-to-Speech Voice file type 				}		kTextToSpeechVoiceBundleType = 'ttvb';	{ Text-to-Speech Voice Bundle file type			}	{ Speech Manager error codes (Range from 240 - 259) }		noSynthFound = -240;		synthOpenFailed = -241;		synthNotReady = -242;		bufTooSmall = -243;		voiceNotFound = -244;		incompatibleVoice = -245;		badDictFormat = -246;		badInputText = -247;	{ constants for SpeakBuffer and TextDone callback controlFlags bits }		kNoEndingProsody = 1;		kNoSpeechInterrupt = 2;		kPreflightThenPause = 4;	{ constants for StopSpeechAt and PauseSpeechAt }		kImmediate = 0;		kEndOfWord = 1;		kEndOfSentence = 2;	{ GetSpeechInfo & SetSpeechInfo selectors }		soStatus = 'stat';		soErrors = 'erro';		soInputMode = 'inpt';		soCharacterMode = 'char';		soNumberMode = 'nmbr';		soRate = 'rate';		soPitchBase = 'pbas';		soPitchMod = 'pmod';		soVolume = 'volm';		soSynthType = 'vers';		soRecentSync = 'sync';		soPhonemeSymbols = 'phsy';		soCurrentVoice = 'cvox';		soCommandDelimiter = 'dlim';		soReset = 'rset';		soCurrentA5 = 'myA5';		soRefCon = 'refc';		soTextDoneCallBack = 'tdcb';		soSpeechDoneCallBack = 'sdcb';		soSyncCallBack = 'sycb';		soErrorCallBack = 'ercb';		soPhonemeCallBack = 'phcb';		soWordCallBack = 'wdcb';		soSynthExtension = 'xtnd';	{ Speaking Mode Constants }		modeText = 'TEXT';		{ input mode constants 	}		modePhonemes = 'PHON';		modeNormal = 'NORM';		{ character mode and number mode constants }		modeLiteral = 'LTRL';	{ GetVoiceInfo selectors }		soVoiceDescription = 'info';	{ gets basic voice info }		soVoiceFile = 'fref';	{ gets voice file ref info }		kNeuter = 0;		kMale = 1;		kFemale = 2;	TYPE		SpeechChannelRecord = Longint;		SpeechChannel = ^SpeechChannelRecord;		SpeechChannelPtr = ^SpeechChannel;		VoiceSpec = RECORD				creator: OSType;			{ creator id of required synthesizer 	}				id: OSType;			{ voice id on the specified synth 		}			END;		VoiceSpecPtr = ^VoiceSpec;		VoiceDescription = RECORD				length: Longint;				{ size of structure - set by application 	}				voice: VoiceSpec;				{ voice creator and id info 			}				version: Longint;				{ version code for voice 				}				name: Str63;					{ name of voice 						}				comment: Str255;					{ additional text info about voice 		}				gender: Integer;				{ neuter, male, or female				}				age: Integer;				{ approximate age in years 				}				script: Integer;				{ script code of text voice can process }				language: Integer;				{ language code of voice output speech 	}				region: Integer;				{ region code of voice output speech 	}				reserved1: Longint;				{ always zero - reserved for future use	}				reserved2: Longint;				{ always zero - reserved for future use	}				reserved3: Longint;				{ always zero - reserved for future use	}				reserved4: Longint;				{ always zero - reserved for future use	}			END;		VoiceDescriptionPtr = ^VoiceDescription;		VoiceFileInfo = RECORD				fileSpec: FSSpec;					{ volume, dir, & name information for voice file }				resID: Integer;				{ resource id of voice in the file }			END;		VoiceFileInfoPtr = ^VoiceFileInfo;		SpeechStatusInfo = RECORD				outputBusy: Boolean; { TRUE if audio is playing}				outputPaused: Boolean; { TRUE if channel is paused}				inputBytesLeft: Longint; { bytes of input left to process}				phonemeCode: Integer; { code for current phoneme}			END;		SpeechStatusInfoPtr = ^SpeechStatusInfo;		SpeechModeInfo = RECORD				inputMode: OSType;	{'TEXT' or 'PHON'}				characterMode: OSType;	{'NORM' or 'LTRL'}				numberMode: OSType;	{'NORM' or 'LTRL'}			END;		SpeechModeInfoPtr = ^SpeechModeInfo;		SpeechVersionInfo = RECORD				synthType: OSType;			{ always ‘ttsc’ }				synthSubType: OSType;			{ Flavor of synth }				synthManufacturer: OSType;			{ synth creator ID }				synthFlags: Longint;		{ synth feature flags }				synthVersion: NumVersion; 	{ synth version number }			END;		SpeechVersionInfoPtr = ^SpeechVersionInfo;	TYPE		speechXtndData = RECORD				synthCreator: OSType;						{synthesizer ID selector}				synthData: PACKED ARRAY[0..1] OF Char;{ data bytes TBD by synthesizer }			END;		DelimiterInfo = RECORD				startDelimiter: PACKED ARRAY[0..1] OF Char;				endDelimiter: PACKED ARRAY[0..1] OF Char;			END;		SpeechErrorInfo = RECORD				count: Integer;			{ # of errs since last check 		}				oldest: OSErr;				{ oldest unread error 				}				oldPos: Longint;			{ char position of oldest err 		}				newest: OSErr;				{ most recent error 				}				newPos: Longint;			{ char position of newest err 		}			END;		PhonemeInfo = RECORD				opcode: Integer;		{ opcode for the phoneme 			}				phStr: Str15;			{ corresponding char string 		}				exampleStr: Str31;			{ word that shows use of phoneme 	}				hiliteStart: Integer;		{ segment of example word that	 	}				hiliteEnd: Integer;		{ should be hilighted (ala TextEdit) }			END;		PhonemeDescriptor = RECORD				phonemeCount: Integer; 						{ # of elements 	}				thePhonemes: ARRAY[0..0] OF PhonemeInfo; 	{ element list 		}			END;	VAR		MyChan: SpeechChannel;		SpeechError: OSErr;		SpeechFlag: Boolean;		SpeechAvailable: Boolean;	FUNCTION SpeechManagerVersion: NumVersion;	INLINE		$203C, $0000, $000C, $A800;	FUNCTION MakeVoiceSpec (creator: OSType; id: OSType; voice: VoiceSpecPtr): OSErr;	INLINE		$203C, $0604, $000C, $A800;	FUNCTION CountVoices (VAR numVoices: Integer): OSErr;	INLINE		$203C, $0108, $000C, $A800;	FUNCTION GetIndVoice (index: Integer; voice: VoiceSpecPtr): OSErr;	INLINE		$203C, $030C, $000C, $A800;	FUNCTION GetVoiceDescription (voice: VoiceSpecPtr; info: VoiceDescriptionPtr; infoLength: Longint): OSErr;	INLINE		$203C, $0610, $000C, $A800;	FUNCTION GetVoiceInfo (voice: VoiceSpecPtr; selector: OSType; voiceInfo: Ptr): OSErr;	INLINE		$203C, $0614, $000C, $A800;	FUNCTION StopSpeech (chan: SpeechChannel): OSErr;	INLINE		$203C, $022C, $000C, $A800;	FUNCTION SetSpeechRate (chan: SpeechChannel; rate: Fixed): OSErr;	INLINE		$203C, $0444, $000C, $A800;	FUNCTION GetSpeechRate (chan: SpeechChannel; rate: FixedPtr): OSErr;	INLINE		$203C, $0448, $000C, $A800;	FUNCTION SetSpeechPitch (chan: SpeechChannel; pitch: Fixed): OSErr;	INLINE		$203C, $044C, $000C, $A800;	FUNCTION GetSpeechPitch (chan: SpeechChannel; pitch: FixedPtr): OSErr;	INLINE		$203C, $0450, $000C, $A800;	FUNCTION UseDictionary (chan: SpeechChannel; dictionary: Handle): OSErr;	INLINE		$203C, $0460, $000C, $A800;	FUNCTION NewSpeechChannel (voice: VoiceSpecPtr; VAR chan: SpeechChannel): OSErr;	INLINE		$203C, $0418, $000C, $A800;	FUNCTION DisposeSpeechChannel (chan: SpeechChannel): OSErr;	INLINE		$203C, $021C, $000C, $A800;	FUNCTION SpeakString (s: Str255): OSErr;	INLINE		$203C, $0220, $000C, $A800;	FUNCTION SpeakText (chan: SpeechChannel; textBuf: Ptr; byteLen: LongInt): OSErr;	INLINE		$203C, $0624, $000C, $A800;	FUNCTION SpeakBuffer (chan: SpeechChannel; textBuf: Ptr; byteLen: LongInt; controlFlags: LongInt): OSErr;	INLINE		$203C, $0828, $000C, $A800;	FUNCTION StopSpeechAt (chan: SpeechChannel; whereToStop: LongInt): OSErr;	INLINE		$203C, $0430, $000C, $A800;	FUNCTION PauseSpeechAt (chan: SpeechChannel; whereToPause: LongInt): OSErr;	INLINE		$203C, $0434, $000C, $A800;	FUNCTION ContinueSpeech (chan: SpeechChannel): OSErr;	INLINE		$203C, $0238, $000C, $A800;	FUNCTION SpeechBusy: Integer;	INLINE		$203C, $003C, $000C, $A800;	FUNCTION SpeechBusySystemWide: Integer;	INLINE		$203C, $0040, $000C, $A800;	FUNCTION GetSpeechInfo (chan: SpeechChannel; selector: OSType; speechInfo: Ptr): OSErr;	INLINE		$203C, $0658, $000C, $A800;	FUNCTION SetSpeechInfo (chan: SpeechChannel; selector: OSType; speechInfo: Ptr): OSErr;	INLINE		$203C, $0654, $000C, $A800;	FUNCTION TextToPhonemes (chan: SpeechChannel; textBuf: Ptr; textBytes: LongInt; phonemeBuf: Handle; phonemeBytes: LongIntPtr): OSErr;	INLINE		$203C, $0A5C, $000C, $A800;	PROCEDURE MySpeechTest (VoiceNumber, SpeechLength: Integer; SpeechBuffer: Ptr);IMPLEMENTATION	PROCEDURE MySpeechTest (VoiceNumber, SpeechLength: Integer; SpeechBuffer: Ptr);		VAR			i, x: Integer;			MyCreator: OSType;			MyID: OSType;			MyVoiceSpec: VoiceSpec;			VoiceCount: Integer;			LongTemp: LongInt;			MyVoiceDescription: VoiceDescription;			TestName: Str255;			MyPitch: Fixed;			Gender: Integer;			PitchChange: Fixed;			RateChange: Fixed;			MyRate: Fixed;	BEGIN		IF SpeechFlag THEN			BEGIN				SpeechError := CountVoices(VoiceCount);				CASE VoiceNumber OF					1: 						BEGIN							TestName := 'Albert';							PitchChange := 24;							RateChange := 48;						END;					2: 						BEGIN							TestName := 'Princess';							PitchChange := 24;							RateChange := 24;						END;					3: 						BEGIN							TestName := 'Ralph';							PitchChange := 20;							RateChange := 16;						END;					4: 						BEGIN							TestName := 'Fred';							PitchChange := 16;							RateChange := 32;						END;					5: 						BEGIN							TestName := 'Junior';							PitchChange := 20;							RateChange := 16;						END;					6: 						BEGIN							TestName := 'Ralph';							PitchChange := 16;							RateChange := 20;						END;					7: 						BEGIN							TestName := 'Junior';							PitchChange := 24;							RateChange := 24;						END;					8: 						BEGIN							TestName := 'Ralph';							PitchChange := 20;							RateChange := 16;						END;					9: 						BEGIN							TestName := 'Bahh';							PitchChange := 12;							RateChange := 20;						END;					10: 						BEGIN							TestName := 'Kathy';							PitchChange := 12;							RateChange := 16;						END;					11: 						BEGIN							TestName := 'Fred';							PitchChange := 20;							RateChange := 16;						END;					12: 						BEGIN							TestName := 'Agnes';							PitchChange := 20;							RateChange := 16;						END;					13: 						BEGIN							TestName := 'Kathy';							PitchChange := 14;							RateChange := 20;						END;					14: 						BEGIN							TestName := 'Agnes';							PitchChange := 14;						END;					15: 						BEGIN							TestName := 'Princess';							PitchChange := 20;							RateChange := 20;						END;					16: 						BEGIN							TestName := 'Princess';							PitchChange := 20;							RateChange := 16;						END;					17: 						BEGIN							TestName := 'Bahh';							PitchChange := 16;							RateChange := 20;						END;				END;				i := 1;				REPEAT					SpeechError := GetIndVoice(i, @MyVoiceSpec);					LongTemp := SizeOf(VoiceDescription);					SpeechError := GetVoiceDescription(@MyVoiceSpec, @MyVoiceDescription, LongTemp);					i := i + 1;				UNTIL (i > VoiceCount) | (MyVoiceDescription.Name = TestName);				IF i <= VoiceCount THEN					BEGIN						SpeechError := GetIndVoice(i - 1, @MyVoiceSpec);						LongTemp := SizeOf(VoiceDescription);						SpeechError := GetVoiceDescription(@MyVoiceSpec, @MyVoiceDescription, LongTemp);						SpeechError := DisposeSpeechChannel(MyChan);						SpeechError := NewSpeechChannel(@MyVoiceSpec, MyChan);						SpeechError := GetSpeechPitch(MyChan, @MyPitch);						MyPitch := (MyPitch * PitchChange) DIV 16;						SpeechError := SetSpeechPitch(MyChan, MyPitch);						SpeechError := GetSpeechRate(MyChan, @MyRate);						MyRate := (MyRate * RateChange) DIV 16;						SpeechError := SetSpeechRate(MyChan, MyRate);						SpeechError := SpeakText(MyChan, SpeechBuffer, SpeechLength);					END;			END;	END;END.