{******************************************************************************************} PROCEDURE EyeShift;{Kevin, don't bother supporting this procedure until you have everything else working.}  VAR   i, j, k, x, y, z: Integer;   CEyeGrafPtr: CGrafPtr;   EyeRgn: RgnHandle;   EyeRect: Rect;   LeftEyeHorzOffset: Integer;   LeftEyeVertOffset: Integer;   RightEyeHorzOffset: Integer;   RightEyeVertOffset: Integer;   Leftdy: Integer;   Rightdy: Integer;   LR: Rect;   RR: Rect;   TempRgn: RgnHandle;   Temp2Rgn: RgnHandle;   TimeClock: LongInt;   DirShift: Integer;   TempRect: Rect; BEGIN  SetRect(TempRect, 0, 0, 400, 245);  CreateOffscreenPixMap(CEyeGrafPtr, TempRect)  SetPort(GrafPtr(CEyeGrafPtr));  FillRect(TempRect, white);  Leftdy := BaseY - FaceLength + Expression[Eye].LVert[1] - LeftEyeRect.top;  LR := LeftEyeRect;  OffsetRect(LR, -LeftEyeRect.left, -LeftEyeRect.top);  CopyBits(MainWind^.portbits, GrafPtr(CEyeGrafPtr)^.portbits, LeftEyeRect, LR, srcCopy, NIL);  Rightdy := BaseY - FaceLength + Expression[Eye].RVert[1] - RightEyeRect.top;  RR := RightEyeRect;  OffsetRect(RR, -RightEyeRect.left + LeftEyeRgn^^.rgnBBox.right, -RightEyeRect.top);  CopyBits(MainWind^.portbits, GrafPtr(CEyeGrafPtr)^.portbits, RightEyeRect, RR, srcCopy, NIL);  LeftEyeHorzOffset := LR.right - Expression[Eye].LHorz[1] - 1;  LeftEyeVertOffset := Leftdy - Expression[Eye].LVert[1];  RightEyeHorzOffset := RR.left - Expression[Eye].RHorz[1];  RightEyeVertOffset := Rightdy - Expression[Eye].RVert[1];  EyeRgn := NewRgn;  TempRgn := NewRgn;  Temp2Rgn := NewRgn;  TimeClock := TickCount + 1;  IF Random > 0 THEN   DirShift := 1  ELSE   DirShift := -1;  FOR i := 1 TO 8 DO   BEGIN    IF i > 4 THEN     k := 8 - i    ELSE     k := i;    CopyRgn(LeftEyeRgn, EyeRgn);    InsetRgn(EyeRgn, 1, 1);    FillRgn(EyeRgn, white);{Despite all appearances, this really is calculating iris position!}    x := LeftEyeHorzOffset + Expression[LowerLip].LHorz[6] + k * 2 * DirShift;    y := LeftEyeVertOffset + Expression[LowerLip].LVert[6];    z := 6 - Expression[LowerLip].RVert[8];    SetRect(TempRect, x - 6, y - 6, x + 6, y + 6);    OpenRgn;    FrameOval(TempRect);    CloseRgn(Temp2Rgn);    SectRgn(EyeRgn, Temp2Rgn, TempRgn);    RGBForeColor(EyeColor);    FillRgn(TempRgn, black);    RGBForeColor(BlackColor);    InsetRect(TempRect, z, z);    OpenRgn;    FrameOval(TempRect);    CloseRgn(Temp2Rgn);    SectRgn(TempRgn, Temp2Rgn, TempRgn);    FillRgn(TempRgn, black);    MoveTo(LR.right, Leftdy);    FOR j := 2 TO ObjectLength[Eye] DO     LineTo(LeftEyeHorzOffset + Expression[Eye].LHorz[j], LeftEyeVertOffset + Expression[Eye].LVert[j]);    LineTo(LR.right, Leftdy);    CopyRgn(RightEyeRgn, EyeRgn);    InsetRgn(EyeRgn, 1, 1);    FillRgn(EyeRgn, white);{Despite all appearances, this really is calculating iris position!}    x := RightEyeHorzOffset + Expression[LowerLip].RHorz[6] + k * 2 * DirShift;    y := RightEyeVertOffset + Expression[LowerLip].RVert[6];    z := 6 - Expression[LowerLip].RVert[8];    SetRect(TempRect, x - 6, y - 6, x + 6, y + 6);    OpenRgn;    FrameOval(TempRect);    CloseRgn(Temp2Rgn);    SectRgn(EyeRgn, Temp2Rgn, TempRgn);    RGBForeColor(EyeColor);    FillRgn(TempRgn, black);    RGBForeColor(BlackColor);    InsetRect(TempRect, z, z);    OpenRgn;    FrameOval(TempRect);    CloseRgn(Temp2Rgn);    SectRgn(TempRgn, Temp2Rgn, TempRgn);    FillRgn(TempRgn, black);    MoveTo(RR.left, Rightdy);    FOR j := 2 TO ObjectLength[Eye] DO     LineTo(RightEyeHorzOffset + Expression[Eye].RHorz[j], RightEyeVertOffset + Expression[Eye].RVert[j]);    LineTo(RR.left, Rightdy);    CopyBits(GrafPtr(CEyeGrafPtr)^.portbits, MainWind^.portbits, LR, LeftEyeRect, srcCopy, NIL);    CopyBits(GrafPtr(CEyeGrafPtr)^.portbits, MainWind^.portbits, RR, RightEyeRect, srcCopy, NIL);    REPEAT    UNTIL TickCount > TimeClock;    TimeClock := TickCount + 1;   END; {i-loop}  DisposPtr(Ptr(CEyeGrafPtr^.portpixmap^^.baseAddr));  CloseCPort(CEyeGrafPtr);  DisposeRgn(EyeRgn);  DisposeRgn(TempRgn);  DisposeRgn(Temp2Rgn);  SetPort(MainWind); END;{******************************************************************************************} PROCEDURE Blink;  VAR   i, j, k, x, y, z: Integer;   CEyeGrafPtr: CGrafPtr;   EyeRgn: RgnHandle;   EyeRect: Rect;   LeftEyeHorzOffset: Integer;   LeftEyeVertOffset: Integer;   RightEyeHorzOffset: Integer;   RightEyeVertOffset: Integer;   Leftdy: Integer;   Rightdy: Integer;   LR: Rect;   RR: Rect;   TempRgn: RgnHandle;   Temp2Rgn: RgnHandle;   TimeClock: LongInt;   DeltaY: Integer;   TempRect: Rect; BEGIN  SetRect(TempRect, 0, 0, 400, 245);  CreateOffscreenPixMap(CEyeGrafPtr, TempRect)  SetPort(GrafPtr(CEyeGrafPtr));  FillRect(TempRect, white);  Leftdy := BaseY - FaceLength + Expression[Eye].LVert[1] - LeftEyeRect.top;  LR := LeftEyeRect;  OffsetRect(LR, -LeftEyeRect.left, -LeftEyeRect.top);  CopyBits(MainWind^.portbits, GrafPtr(CEyeGrafPtr)^.portbits, LeftEyeRect, LR, srcCopy, NIL);  Rightdy := BaseY - FaceLength + Expression[Eye].RVert[1] - RightEyeRect.top;  RR := RightEyeRect;  OffsetRect(RR, -RightEyeRect.left + LeftEyeRgn^^.rgnBBox.right, -RightEyeRect.top);  CopyBits(MainWind^.portbits, GrafPtr(CEyeGrafPtr)^.portbits, RightEyeRect, RR, srcCopy, NIL);  LeftEyeHorzOffset := LR.right - Expression[Eye].LHorz[1] - 1;  LeftEyeVertOffset := Leftdy - Expression[Eye].LVert[1];  RightEyeHorzOffset := RR.left - Expression[Eye].RHorz[1];  RightEyeVertOffset := Rightdy - Expression[Eye].RVert[1];  EyeRgn := NewRgn;  TempRgn := NewRgn;  Temp2Rgn := NewRgn;  TimeClock := TickCount + 3;  FOR i := 1 TO 8 DO   BEGIN    RGBForeColor(SkinColor[4]);    FillRgn(LeftEyeRgn, black);    FillRgn(RightEyeRgn, black);    RGBForeColor(BlackColor);    IF i > 4 THEN     k := 8 - i    ELSE     k := i;    OpenRgn;    MoveTo(LR.right, Leftdy);    FOR j := 2 TO 5 DO     BEGIN      DeltaY := Expression[Eye].LVert[12 - j] - Expression[Eye].LVert[j];      y := Expression[Eye].LVert[j] + ((k * DeltaY) DIV 4);      LineTo(LeftEyeHorzOffset + Expression[Eye].LHorz[j], LeftEyeVertOffset + y);     END;    FOR j := 6 TO ObjectLength[Eye] DO     LineTo(LeftEyeHorzOffset + Expression[Eye].LHorz[j], LeftEyeVertOffset + Expression[Eye].LVert[j]);    LineTo(LR.right, Leftdy);    CloseRgn(EyeRgn);    FillRgn(EyeRgn, white);    x := LeftEyeHorzOffset + Expression[LowerLip].LHorz[6];    y := LeftEyeVertOffset + Expression[LowerLip].LVert[6];    z := 6 - Expression[LowerLip].RVert[8];    SetRect(TempRect, x - 6, y - 6, x + 6, y + 6);    OpenRgn;    FrameOval(TempRect);    CloseRgn(Temp2Rgn);    SectRgn(EyeRgn, Temp2Rgn, TempRgn);    RGBForeColor(EyeColor);    FillRgn(TempRgn, black);    RGBForeColor(BlackColor);    InsetRect(TempRect, z, z);    OpenRgn;    FrameOval(TempRect);    CloseRgn(Temp2Rgn);    SectRgn(TempRgn, Temp2Rgn, TempRgn);    FillRgn(TempRgn, black);    OpenRgn;    MoveTo(RR.left, Rightdy);    FOR j := 2 TO 5 DO     BEGIN      DeltaY := Expression[Eye].RVert[12 - j] - Expression[Eye].RVert[j];      y := Expression[Eye].RVert[j] + ((k * DeltaY) DIV 4);      LineTo(RightEyeHorzOffset + Expression[Eye].RHorz[j], RightEyeVertOffset + y);     END;    FOR j := 6 TO ObjectLength[Eye] DO     LineTo(RightEyeHorzOffset + Expression[Eye].RHorz[j], RightEyeVertOffset + Expression[Eye].RVert[j]);    LineTo(RR.left, Rightdy);    CloseRgn(EyeRgn);    FillRgn(EyeRgn, white);    x := RightEyeHorzOffset + Expression[LowerLip].RHorz[6];    y := RightEyeVertOffset + Expression[LowerLip].RVert[6];    z := 6 - Expression[LowerLip].RVert[8];    SetRect(TempRect, x - 6, y - 6, x + 6, y + 6);    OpenRgn;    FrameOval(TempRect);    CloseRgn(Temp2Rgn);    SectRgn(EyeRgn, Temp2Rgn, TempRgn);    RGBForeColor(EyeColor);    FillRgn(TempRgn, black);    RGBForeColor(BlackColor);    InsetRect(TempRect, z, z);    OpenRgn;    FrameOval(TempRect);    CloseRgn(Temp2Rgn);    SectRgn(TempRgn, Temp2Rgn, TempRgn);    FillRgn(TempRgn, black);    MoveTo(LR.right, Leftdy);    FOR j := 2 TO 5 DO     BEGIN      DeltaY := Expression[Eye].LVert[12 - j] - Expression[Eye].LVert[j];      y := Expression[Eye].LVert[j] + ((k * DeltaY) DIV 4);      LineTo(LeftEyeHorzOffset + Expression[Eye].LHorz[j], LeftEyeVertOffset + y);     END;    FOR j := 6 TO ObjectLength[Eye] DO     LineTo(LeftEyeHorzOffset + Expression[Eye].LHorz[j], LeftEyeVertOffset + Expression[Eye].LVert[j]);    LineTo(LR.right, Leftdy);    MoveTo(RR.left, Rightdy);    FOR j := 2 TO 5 DO     BEGIN      DeltaY := Expression[Eye].RVert[12 - j] - Expression[Eye].RVert[j];      y := Expression[Eye].RVert[j] + ((k * DeltaY) DIV 4);      LineTo(RightEyeHorzOffset + Expression[Eye].RHorz[j], RightEyeVertOffset + y);     END;    FOR j := 6 TO ObjectLength[Eye] DO     LineTo(RightEyeHorzOffset + Expression[Eye].RHorz[j], RightEyeVertOffset + Expression[Eye].RVert[j]);    LineTo(RR.left, Rightdy);    CopyBits(GrafPtr(CEyeGrafPtr)^.portbits, MainWind^.portbits, LR, LeftEyeRect, srcCopy, NIL);    CopyBits(GrafPtr(CEyeGrafPtr)^.portbits, MainWind^.portbits, RR, RightEyeRect, srcCopy, NIL);    REPEAT    UNTIL TickCount > TimeClock;    TimeClock := TickCount + 3;   END; {i-loop}  DisposPtr(Ptr(CEyeGrafPtr^.portpixmap^^.baseAddr));  CloseCPort(CEyeGrafPtr);  DisposeRgn(EyeRgn);  DisposeRgn(TempRgn);  DisposeRgn(Temp2Rgn);  SetPort(MainWind); END;