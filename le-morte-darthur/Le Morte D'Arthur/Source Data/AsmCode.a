;   Dissolve;;   This procedure takes a bitmap and shimmers it.; The input parameters are specified in the opening code, which; some of them wastefully for the sole purpose of unambiguously; declaring where they are.;;		DEFINITION OF TERMS AND PARAMETERS USED;; Dissolve index: This is a measure of what fraction of the image;			will be displayed, measured in 16ths of completeness.;			A value of 16 indicates no image display;			A value of 8 indicates 50% image display;			A value of 0 indicates complete image display;; Shimmer Phase:	This gives the phase angle on the last scan line.;			It is measured in units of steps in the SinTable array,;			whatever those might be. By changing this parameter on;			a sequence of calls, the image is made to wave.;; Shimmer Amplitude: This is the amplitude of the shimmer wave, measured;			in pixels. By steadily reducing this value, ;			the shimmer dies away.;; SrcBMap height:	This is the vertical size of the source bitmap.;			The code is smart enough to handle variable size bitmaps.;; SrcBMap width:	This is the horizontal size of the source bitmap.;			The code is also smart enough to handle horizontal;			variability. Note, however, that the shimmering algorithm;			needs 32 pixels of blank space on the right edge of;			the bitmap to accomodate the waving pixels.;; SrcBMap.baseaddr: This is the address of the bitmap data of the source;			image. The routine will grab pixels out of here,;			shimmer them, and store the result into...;; DestBMap.baseaddr: This is the address of the bitmap into which you;			want the results stored. Set it up the data structure;			before calling this routine.;; IndexArr:		This one is confusing. Its purpose is to provide;			randomized indeces into the MaskArr table. This gives;			a more random-looking dissolve.;; MaskArr:		This is an array of random numbers with progressively;			more bits set. They come in groups of 16, each group;			having approximately the same number of bits set. Thus,;			the first group has about one bit set in every integer;;			the second group has two bits set, the third group has;			three bits set, and so on up to the 15th group. The;			16th and 17th groups have all bits set.;; SinTable:		This is just an array of integers representing sine;			values. Initialize them prior to calling this routine.;			Each integer handles one scan line. Normalize it such;			that the peak value is 256. The wavelength must be;			128 integers long.;			;  A final note: on the Macintosh, a "1" represents a black pixel, while; a zero represents a white pixel. Thus, you OR with a mask to push; an image toward black, while you AND with a mask to push towards; white.;    BLANKS ON    STRING ASISDISSOLVE PROC      EXPORT 	LINK		A6,#0	MOVEM.L	D0-D7/A0-A5,-(A7)		;preserve existing registers	;   First we load in all parameters off of the local stack frame.; Some of these, you will note, are read over each other. I'm just; declaring them for convenience. Note that they're pulled off in; stack order, the reverse of the arguement list in the Pascal code.;	MOVE.L	$8(A6),A4	;SinTable address	MOVE.L	$C(A6),A3	;MaskArr address	MOVE.L	$10(A6),A2	;IndexArr address	MOVE.L	$14(A6),A1	;DestBMap.baseaddr	MOVE.L	$18(A6),A0	;SrcBMap.baseaddr	MOVE.W	$1C(A6),D3	;SrcBMap width	MOVE.W	$1E(A6),D7	;SrcBMap height	MOVE.W	$20(A6),D3	;Shimmer Amplitude	MOVE.W	$22(A6),D3	;Shimmer Phase	MOVE.W	$24(A6),D4	;dissolve index;; This is the outer loop, whose loop index is in D7 and represents a; scan line counter. We start at the bottom of the bitmap and work; backwards to the beginning -- efficient but harder to understand.; This first chunk calculates the offset into the bitmap, which offset; is stored in D2. The pixel counter in D5 is used to get the offset for; the IndexArr.;LOOP2	MOVE.W	D7,D2		;Line Counter	MULU		$1C(A6),D2	;bitmap width	MOVE.L	D2,D5		;save pixel counter	LSR.L		#1,D5		;halve for byte count	AND.W		#$37F,D5	;mask off to fit into IndexArr	LSR.L		#3,D2		;byte counter	SUBQ		#4,D2		;last word of previous line	MOVE.W	$1C(A6),D3	;bitmap width	; Now that we have the offset, we must calculate the amount of shift; that we will apply to this scan line. Note that this is always a; shift to the right, never to the left. This "biased shift" simplifies; the calculation, but you have to remember it when you do a straight; CopyBits. Also, it would have been faster to shift bidirectionally.; The result of all this work ends up in D4, the number of pixels to; shift rightward.;	MOVE.W	D7,D4		;line counter	ADD.W		$22(A6),D4	;add shimmer phase	AND.W		#$7F,D4	;truncate to one wavelength	ASL.W		#1,D4		;double for byte count	MOVE.W	0(A4,D4),D4	;obtain sine value	MULS		$20(A6),D4	;multiply by amplitude	ASR.L		#8,D4		;divide by 256	ADDI.W	#16,D4	;bias rightward by 16 pixels; This inner loop is used to shift bits within 32-bit longwords.; The control variable is in D3, the bitmap width measured in pixels.; This first chunk grabs a longword and performs the dissolve by OR-ing; the source image with the mask.;LOOP3	MOVE.L	0(A0,D2),D0	;source image	MOVE.W	0(A2,D5),D1	;randomizing IndexArr element	ADD.W		$24(A6),D1	;add dissolve index	MOVE.L	0(A3,D1),D1	;obtain mask	OR.L		D1,D0		;or mask with image to suppress white pixels; This next chunk rotates the image rightward by D4 pixels. Then we; split the longword up: the lower D4 pixels are saved, and the upper 32-D4; pixels are masked out and or-ed into the next longword.;	ROR.L		D4,D0		;rotate the longword right by D4 bits	CLR.L		D1		;set D1 to zero	NOT.L		D1		;invert it to obtain $FFFFFFFF (a mask)	LSR.L		D4,D1		;now shift the mask right by D4 bits	MOVE.L	D0,D6		;move the rotated image longword to D6	AND.L		D1,D6		;mask out upper bits	MOVE.L	D6,0(A1,D2)	;save result to bitmap	CMP.W		$1C(A6),D3	;are we on our first pass?	BEQ.S		SKIP1		;if so, skip	NOT.L		D1		;if not, invert the mask	MOVE.L	D0,D6		;move original rotated image back to D6	AND.L		D1,D6		;mask with new inverted mask	;This next line is tricky -- it OR's the upper 32 - D6 bits into a;longword that is four bytes beyond the current longword pointed to by;(A1,D2). That longword was stored into in the previous pass of this;loop. Thus, storing a complete longword is a two-step process. We;get the low-order bits on the first pass, and the high-order bits on;the second pass. This will only work, of course, if we don't have to;do special processing on the first longword of the scanline (which we don't!)	OR.L		D6,4(A1,D2)	;or the result into the bitmap	;Now we see if we're at the beginning of the scanlineSKIP1	TST	D2	BNE.S		SKIP2; This snippet patches up the left edge of the image.; Its purpose is to correct the fact that there will be no second-pass; correction of the upper 32 - D6 bits in the longword. This corrects; that oversight in the algorithm. Hey, it's a hack...	OR.L		D1,0(A1,D2);and now we're ready to terminate the loop for one scanlineSKIP2	SUBQ		#4,D2		;move back four bytes	SUB.W		#32,D3	;move back one longword	BPL.S		LOOP3	;This terminates the outer loop.	SUBQ		#1,D7	BNE.S		LOOP2; This is standard 68000 code for cleaning up a subroutine and;returning control to the main program	MOVEM.L   (A7)+,D0-D7/A0-A5	UNLK      A6	MOVE.L    (A7)+,A0	ADDA.L    #30,A7		;30 bytes were put onto the stack	JMP       (A0)     ; These remaining routines are not associated with Shimmer.; They're just some interesting routines that I've always preserved here.;MYSQRT FUNC      EXPORT      MOVE.L    (A7)+,A0	      ;return address     MOVE.L    (A7)+,D0	      ;value whose square root is desired     BNE.S     X1	      ;if zero, return     JMP       (A0)X1   MOVE      (A7)+,D1	      ;clear function return value off stack     MOVE.L    D3,-(A7)	      ;save register D3     MOVEQ     #0,D1	      ;clear D1     MOVEQ     #$20,D2	      ;set bit counter in D2LP2  SUBQ      #1,D2	      ;decrement bit counter     ADDQ      #1,D1	      ;increment return counter     ROL.L     #1,D0	      ;shift once     BCC.S     LP2	      ;if bit isn't set, keep shifting     ROR.L     D1,D0	      ;restore D0 to original setting     LSR       #1,D2	      ;halve bit count for square root     ;for the remainder of the code, the registers hold:     ;	 D0:  trial square root, trial square     ;	 D1:  trial square root     ;	 D2:  bit counter     ;	 D3:  true square value     MOVE.L    D0,D3	      ;set up true square value     MOVEQ     #1,D1	      ;initialize trial square value     ROL       D2,D1LP3  MOVE      D1,D0	      ;move trial square root into D0 for multiplication     MULU      D1,D0     CMP.L     D0,D3	      ;compare square with input value     BEQ.S     X2	      ;if equal, we've got it     BCC.S     X3	      ;if trial value is too small, retain this bit     MOVEQ     #1,D0	      ;trial value is too large, delete this bit     ROL       D2,D0	      ;select the bit     EOR       D0,D1	      ;strip the bit out of D1X3   SUBQ      #1,D2	      ;next lower bit     BMI.S     X2	      ;if that was last bit, quit     MOVEQ     #1,D0	      ;set up the next bit to or in     ROL       D2,D0	      ;move bit into position     OR	       D0,D1	      ;or this bit into trial square root     BRA.S     LP3	      ;try this value out for sizeX2   MOVE.L    (A7)+,D3	      ;restore D3     MOVE      D1,-(A7)	      ;return function result     JMP       (A0)	      ;...and into the sunset...HIBYTE FUNC      EXPORT      MOVE.L    (A7)+,A0	      ;return address     MOVE.W    (A7)+,D0	      ;input value     MOVE.W    (A7)+,D1	      ;return value -- throw away     LSR.W     #8,D0	      ;shift down high byte     ANDI.W    #$FF,D0	      ;just for safety's sake     EXT       D0     MOVE.W    D0,-(A7)     JMP       (A0)LOBYTE FUNC      EXPORT      MOVE.L    (A7)+,A0	      ;return address     MOVE.W    (A7)+,D0	      ;input value     MOVE.W    (A7)+,D1	      ;return value -- throw away     ANDI.W    #$FF,D0	      ;isolate low byte     EXT       D0     MOVE.W    D0,-(A7)     JMP       (A0)     END