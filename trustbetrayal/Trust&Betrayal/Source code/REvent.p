UNIT REvent;INTERFACEUSES{$L-}{$U-}   {$LOAD MQOTP.dumpfile}       Memtypes, QuickDraw, OSIntf, ToolIntf, PackIntf,	 {$LOAD Globals.dumpfile}   {$U Globals.p}  Globals;	 {$LOAD}{$U+}{$SETC DebugFlg:=FALSE}PROCEDURE RandEvent(Context,Who: Integer);IMPLEMENTATION{$S RandEvents}{*************************************************************************}PROCEDURE RandEvent;CONST  Travelling = 1;  InHisHome  = 2;  InMyHome   = 3;  HeWasWaiting = 4;  IWasWaiting = 5;  IWasThere = 6;  OptnMax = 500;VAR  i,j,k,x,y,StoryNum: Integer;  LoclRect:    	Rect;  LoclBits:    	ARRAY[1..10304] OF Integer;  LoclBMap:    	BitMap;  TempRect:	   	Rect;  PrevRect:	   	Rect;  NextRect:    	Rect;  DoneRect:	   	Rect;  OptSelect:   	Integer;  MyFlag:      	Boolean;  error,JErr:  	OSErr;  RefNum:	   	Integer;  Count:	   	LongInt;  StoryIn:	   	PACKED ARRAY[0..4095] OF Char;  StoryOut:	   	PACKED ARRAY[0..4095] OF Char;  TestStr:	   	String[70];  StartI,EndI: 	Integer;  LineNum:	   	Integer;  SaveStart:   	ARRAY[1..8] OF Integer;  SSIndex:     	Integer;  EndFlag:	   	Boolean;  StartFlag:  	Boolean;  LastChar:    	Integer;  CapFlag:	   	Boolean;  OldJ:		   	Integer;  TempStr:     	Str255;  NumString:   	Str255;  LongX:       	LongInt;  LoveMH:  	Integer;  TrustMH:	   	Integer;  FearMH: 	Integer;  OptnComd:	   	ARRAY[1..4] OF PACKED ARRAY[1..OptnMax] OF Char;  FaceRect:	   	Rect;  Value:	   	Integer;  TempNum:	   	Integer;  WhoseFace:	Integer;  TempFlag:		Boolean;{--------------------------------------------------------------------------}PROCEDURE RandError(IDNum,Param: Integer; error: OSerr);VAR  i:	Integer;BEGIN  SetRect(TempRect,80,240,400,300);  FillRect(TempRect,white);  FrameRect(TempRect);  MoveTo(84,260);  DrawString('Report Random Event Error #');  MyWrite(IDNum);  DrawString(' Class:');  MyWrite(error);  MoveTo(84,276);  CASE IDNum OF    1: DrawString('Cannot find Story');;	2: DrawString('Cannot read Story');	3: DrawString('Unterminated Command');	4: DrawString('F-comd has bad operand');	5: DrawString('final X-Value:');	6: BEGIN DrawString('Bad string: '); 	         FOR i:=1 TO 30 DO DrawChar(OptnComd[OptSelect,i]);	   END;  END;  MyWrite(Param);  MoveTo(84,292);  DrawString('Press Mouse to continue.');  REPEAT SystemTask; UNTIL Button;END;{--------------------------------------------------------------------------}PROCEDURE ExecComd;VAR  TermFlag:   Boolean;  x,y,z,t:    Integer;  Value,j,k:  Integer;  ThisChar:   Char;  TempNum:    Integer;  Register:   Integer;  LineCt:     Integer;  JunkNum:	  Integer;{..........................................................................}PROCEDURE Push(Number: Integer);BEGIN  t:=z;  z:=y;  y:=x;  x:=Number;END;{..........................................................................}PROCEDURE Pop;BEGIN  x:=y;  y:=z;  z:=t;END;{..........................................................................}PROCEDURE ReadNum;BEGIN  i:=i+1;  Value:=ord(OptnComd[OptSelect,i])-48;  IF (Value<0) OR (Value>9) THEN RandError(4,Value,0);  TempNum:=ord(OptnComd[OptSelect,i+1]);  IF (TempNum>=48) AND (TempNum<=57) THEN    BEGIN      Value:=10*Value+TempNum-48;      i:=i+1;    END;END;{..........................................................................}BEGIN  MyFlag:=TRUE;  TermFlag:=FALSE;  i:=1;  MoveTo(10,322);   WHILE (i<OptnMax) AND NOT TermFlag DO    BEGIN	  ThisChar:=OptnComd[OptSelect,i];	  CASE ThisChar OF	    '0'..'9': BEGIN		            i:=i-1;					ReadNum;					Push(Value);				  END;		'A': Push(Love[Who,Player]);		'D': Push(-Fear[Who,Player]);		'T': Push(Trust[Who,Player]);		'E': Push(Temper[Who]);		'G': Push(Gullble[Who]);		'I': Push(Pride[Who]);		'N': Push(0);		'W': Push(0);		'a': BEGIN Love[Who,Player]:=x; Pop; END;		'd': BEGIN Fear[Who,Player]:=-x; Pop; END;		't': BEGIN Trust[Who,Player]:=x; Pop; END;		'+': BEGIN y:=x+y; Pop; END;		'-': BEGIN y:=y-x; Pop; END;		'*': BEGIN y:=y*x; Pop; END;		'/': BEGIN y:=y div x; Pop; END;		'X': BEGIN TempNum:=y; y:=x; x:=TempNum; END;		'R': BEGIN TempNum:=x; Pop; t:=TempNum; END;		'M': Push(Register);		'm': Register:=x;		'B': IF x>=0 THEN 		       BEGIN			     REPEAT i:=i+1; UNTIL ord(OptnComd[OptSelect,i])=13;				 i:=i+2;			   END;		'S': REPEAT i:=i+1; UNTIL ord(OptnComd[OptSelect,i])=13;		'P': BEGIN  			   ClearRect(170,20,512,229);			   FillRect(PrevRect,white);			   FillRect(NextRect,white);			   FillRect(DoneRect,white);			   FrameRect(DoneRect);			   MoveTo(DoneRect.left+12,DoneRect.top+20);			   DrawString('OK');			   FOR j:=1 TO 4 DO IF j<>OptSelect THEN			     BEGIN				   SetRect(TempRect,0,200+30*j,512,220+30*j);				   FillRect(TempRect,white);				 END;			   i:=i+1;			   LineCt:=1;			   REPEAT			     TempStr:='                                                               ';			     MoveTo(172,30+LineCt*20);			     j:=1;			     REPEAT			       TempStr[j]:=OptnComd[OptSelect,i];				   j:=j+1;				   i:=i+1;				 UNTIL (j=40) OR (ord(OptnComd[OptSelect,i])=13);				 IF ord(OptnComd[OptSelect,i])<>13 THEN 				   REPEAT					 i:=i-1;					 j:=j-1;					 TempStr[j]:=' ';				   UNTIL OptnComd[OptSelect,i]=' ';			     DrawString(TempStr);				 LineCt:=LineCt+1;			   UNTIL ord(OptnComd[OptSelect,i])=13;			   REPEAT i:=i+1; UNTIL OptnComd[OptSelect,i]='\';			   i:=i-1;			 END;	    'F': BEGIN 		       ReadNum; 			 END;	    'C': BEGIN		       ReadNum;			   FOR j:=1 TO NumChars DO 			     BEGIN				   JunkNum:=Love[j,Player]-Value;				   IF JunkNum<-127 THEN JunkNum:=-127;				   Love[j,Player]:=JunkNum;				   JunkNum:=Trust[j,Player]-Value;				   IF JunkNum<-127 THEN JunkNum:=-127;				   Trust[j,Player]:=JunkNum;				   JunkNum:=Fear[j,Player]-Value;				   IF JunkNum<-127 THEN JunkNum:=-127;				   Fear[j,Player]:=JunkNum;				 END;			 END;	    'H': BEGIN		       Aslyn:=Aslyn+x;			   IF StoryNum<23 THEN 				 BEGIN				   FOR j:=StoryNum+1 TO 23 DO					 BEGIN					   IF Aslyn<8 THEN StoryParm[j]:=Abs(StoryParm[j])					   			  ELSE StoryParm[j]:=-Abs(StoryParm[j]);					 END;				 END;			   IF (StoryNum=23) & (Aslyn<8) THEN StoryParm[44]:=Abs(StoryParm[44]);			 END;	    'J': x:=-x;		'Q': BEGIN		       FOR j:=1 TO NumChars DO			     BEGIN				   FOR k:=1 TO 3 DO AuraCnt[k,j,Player]:=AuraCnt[k,j,0];				 END;			 END;	    '\': TermFlag:=TRUE;		otherwise RandError(6,0,0);	  END; {of CASE statement}	  {$IFC DebugFlg}	    {ClearRect(20,270,500,300);	    MoveTo(20,290);	    DrawChar(OptnComd[OptSelect,i]); 		DrawString(' '); 		MyWrite(x);		DrawString(' ');		MyWrite(y);		DrawString(' ');		MyWrite(z);		DrawString(' ');		MyWrite(t);		REPEAT UNTIL Button;		REPEAT UNTIL NOT Button;}	  {$ENDC}	  i:=i+1;	END;  IF NOT TermFlag THEN RandError(3,OptSelect,0);  REPEAT UNTIL NOT Button;  TermFlag:=FALSE;  REPEAT   IF GetNextEvent(everyEvent,myEvent) & (myEvent.what=mouseDown) THEN	BEGIN	  MousePt:=myEvent.where;	  IF PtInRect(MousePt,DoneRect) THEN		IF RectHit(DoneRect) THEN TermFlag:=TRUE;    END;  UNTIL TermFlag;END;{--------------------------------------------------------------------------}PROCEDURE DrawStory;VAR  j:	Integer;BEGIN  ClearRect(170,20,512,229);  TextFont(1);  TextSize(9);   LineNum:=1;  SaveStart[SSIndex]:=StartI;  WHILE (LineNum<16) AND NOT EndFlag DO    BEGIN	  EndI:=StartI+70;	  IF Endi>=LastChar THEN BEGIN EndFlag:=TRUE; Endi:=LastChar; END;      REPEAT EndI:=EndI-1 UNTIL StoryOut[EndI]=' ';      TestStr:='                                                                      ';      FOR j:=StartI TO EndI DO TestStr[j-StartI+1]:=StoryOut[j];      StartI:=EndI+1;      MoveTo(170,20+12*LineNum);      DrawString(TestStr);	  LineNum:=LineNum+1;	END;  TextFont(0);  TextSize(12);  StartFlag:=(SSIndex=1);END;{--------------------------------------------------------------------------}PROCEDURE MyConcat(Insertion: Str255);VAR  i:	Integer;BEGIN  FOR i:=1 TO Length(Insertion) DO StoryOut[j+i-1]:=Insertion[i];  j:=j+Length(Insertion)-1;END;{--------------------------------------------------------------------------}PROCEDURE DrawDone;BEGIN  FrameRect(DoneRect);  MoveTo(15,212); DrawString('Done');END;{--------------------------------------------------------------------------}PROCEDURE DrawPrev;BEGIN  FrameRect(PrevRect);  MoveTo(66,207); DrawString('Prev');  MoveTo(65,218); DrawString('Page');END;{--------------------------------------------------------------------------}PROCEDURE DrawNext;BEGIN  FrameRect(NextRect);  MoveTo(115,207); DrawString('Next');  MoveTo(115,218); DrawString('Page');END;{--------------------------------------------------------------------------}BEGIN  IF Who>NumChars THEN Exit(RandEvent);  LoveMH:=(Love[Who,Player] div 32);  IF LoveMH>1 THEN LoveMH:=1;  IF LoveMH<-1 THEN LoveMH:=-1;  TrustMH:=(Trust[Who,Player] div 32);  IF TrustMH>1 THEN TrustMH:=1;  IF TrustMH<-1 THEN TrustMH:=-1;  FearMH:=(Fear[Who,Player] div 32);  IF FearMH>1 THEN FearMH:=1;  IF FearMH<-1 THEN FearMH:=-1;  {select an appropriate story}  i:=1;  StoryNum:=-1;  REPEAT    TempNum:=StoryParm[i];    IF (TempNum>=0) & (Random>29000) THEN	  BEGIN	    x:=TempNum mod 8;		IF (x=Who) | (x=0) THEN		  BEGIN		    x:=(TempNum div 8) mod 8;			IF (x=Context) | (x=0) THEN			  BEGIN			    x:=(TempNum div 64) mod 4;				y:=((TempNum div 256) mod 4)-1;				CASE x OF 				  0: TempFlag:=TRUE;				  1: TempFlag:=(LoveMH=y);				  2: TempFlag:=(TrustMH=y);				  3: TempFlag:=(FearMH=y);				END;				IF TempFlag THEN				  BEGIN				    x:=TempNum div 1024;					IF x=0 THEN StoryNum:=i;				  END;			  END;		  END;	  END;    i:=i+1;  UNTIL (i=100) OR (StoryNum>=0);  IF StoryNum>=0 THEN    BEGIN	  LongX:=ord4(StoryNum);	  NumToString(LongX,NumString);          	  TempStr:=Concat(':Stories:Story',NumString);  	  Error:=FSOpen(TempStr,0,RefNum);	  IF error=0 THEN	    BEGIN		  StoryParm[StoryNum]:=-1;		  SetRect(DoneRect,10,194,50,224);		  SetRect(PrevRect,60,194,100,224);		  SetRect(NextRect,110,194,150,224);		  SetRect(LoclRect,0,20,512,342);		  LoclBMap.rowBytes:=64;		  LoclBMap.baseAddr:=@LoclBits;		  LoclBMap.bounds:=LoclRect;		  CopyBits(ScreenBits,LoclBMap,LoclRect,LoclRect,srcCopy,NIL);		  ClearRect(0,20,512,342);		  TextFont(0);		  DrawDone; DrawPrev; DrawNext;		  		  FillChar(StoryIn,4096,' ');		  FillChar(StoryOut,4096,' ');	  		  error:=SetFPos(RefNum,1,0);		  Count:=4096;		  error:=FSRead(RefNum,Count,@StoryIn);		  JErr:=FSClose(RefNum);		  IF (error<>0) AND (error<>EOFErr) THEN RandError(2,StoryNum,error)		  ELSE			BEGIN			  j:=0;			  LastChar:=0;			  FOR i:=0 TO Count-1 DO				BEGIN				  CapFlag:=TRUE;				  OldJ:=j;				  CASE StoryIn[i] OF					'~': MyConcat('you');					'%': BEGIN MyConcat(CharName[Who]); CapFlag:=FALSE; END;					'@': IF Male[Who] THEN MyConcat('he') ELSE MyConcat('she');					'#': IF Male[Who] THEN MyConcat('his') ELSE MyConcat('hers');					'$': IF Male[Who] THEN MyConcat('him') ELSE MyConcat('her');					'^': IF Male[Who] THEN MyConcat('his') ELSE MyConcat('her');					'&': MyConcat(Species[Who]);					'=': MyConcat(Fiance[Player]);					']': MyConcat(Fiance[Who]);					'\': IF LastChar=0 THEN LastChar:=j+1						 ELSE BEGIN StoryOut[j]:=StoryIn[i]; CapFlag:=FALSE; END;					otherwise BEGIN StoryOut[j]:=StoryIn[i]; CapFlag:=FALSE; END;				  END;				  IF CapFlag & ((StoryOut[OldJ-3]='.') 							 | (StoryOut[OldJ-3]='?')							 | (StoryOut[OldJ-3]='!')) THEN					  StoryOut[OldJ]:=Char(ord(StoryOut[OldJ])-32);				j:=j+1;			  END;						WhoseFace:=Who;			CASE StoryNum OF			  15,16,17,18,37,38,39,40,41: WhoseFace:=8;			  9,10,19,20,21,22,23,24,25,30,42: WhoseFace:=0;			END;			IF WhoseFace>0 THEN			  BEGIN				SetRect(FaceRect,6,28,166,188);				CopyBits(Face[WhoseFace],Screenbits,StdRect3,FaceRect,srcCopy,NIL);			  END;			j:=LastChar;			REPEAT			  j:=j+1;			  IF (StoryOut[j]='K') OR (StoryOut[j]='L') THEN				BEGIN 				  j:=j+1;				  Value:=ord(StoryOut[j])-48;				  IF (Value<0) OR (Value>9) THEN RandError(4,Value,0);				  TempNum:=ord(StoryOut[j+1]);				  IF (TempNum>=48) AND (TempNum<=57) THEN					BEGIN					  Value:=10*Value+TempNum-48;					  j:=j+1;					END;				  IF (StoryOut[j]='K') THEN StoryParm[Value]:=Abs(StoryParm[Value]);				  IF (StoryOut[j]='L') THEN StoryParm[Value]:=-Abs(StoryParm[Value]);				END;			UNTIL StoryOut[j]='\';			LastChar:=j+2;			EndFlag:=FALSE;			StartFlag:=TRUE;			SSIndex:=1;			StartI:=0;			DrawStory;			IF StartFlag THEN GrayRect(PrevRect);			IF EndFlag THEN GrayRect(NextRect);			j:=LastChar;			FOR i:=1 TO 4 DO			  BEGIN				MoveTo(15,214+30*i);				REPEAT 				  DrawChar(StoryOut[j]);				  j:=j+1;				UNTIL ord(StoryOut[j])=13;				k:=0;				j:=j+2;				REPEAT				  k:=k+1;				  j:=j+1;				  OptnComd[i,k]:=StoryOut[j];				UNTIL StoryOut[j]='\';				j:=j+2;			  END;			OptSelect:=1;			SetRect(TempRect,0,200+30*OptSelect,512,220+30*OptSelect);			InvertRect(TempRect);			{TextFont(1); TextSize(9); MoveTo(500,340); MyWrite(StoryNum);}			TextFont(0); TextSize(12);		  			MyFlag:=FALSE;			REPEAT			  SystemTask;			  IF GetNextEvent(everyEvent,myEvent) & (myEvent.what=mouseDown) THEN				BEGIN				  MousePt:=myEvent.where;				  IF PtInRect(MousePt,DoneRect) THEN					IF RectHit(DoneRect) THEN ExecComd;				  IF PtInRect(MousePt,NextRect) AND NOT EndFlag THEN					  IF RectHit(NextRect) THEN						BEGIN						  SSIndex:=SSIndex+1;						  DrawStory;						  DrawPrev;						  IF EndFlag THEN GrayRect(NextRect);						END;				  IF PtInRect(MousePt,PrevRect) AND NOT StartFlag THEN					  IF RectHit(PrevRect) THEN						BEGIN 						  SSIndex:=SSIndex-1;						  StartI:=SaveStart[SSIndex];						  EndFlag:=FALSE;						  DrawStory;						  DrawNext;						  IF StartFlag THEN GrayRect(PrevRect);						END;				  FOR i:=1 TO 4 DO IF i<>OptSelect THEN					BEGIN					  SetRect(TempRect,0,200+30*i,512,220+30*i);					  IF PtInRect(MousePt,TempRect) & RectHit(TempRect) THEN						BEGIN						  SetRect(TempRect,0,200+30*OptSelect,512,220+30*OptSelect);						  InvertRect(TempRect);						  OptSelect:=i;						  SetRect(TempRect,0,200+30*OptSelect,512,220+30*OptSelect);						  InvertRect(TempRect);						END;					END;				END;			UNTIL MyFlag;		  END;	  END;   END;  CopyBits(LoclBMap,ScreenBits,LoclRect,LoclRect,srcCopy,NIL);END;  {*************************************************************************}END.