UNIT PlanMyMove;INTERFACEUSES{$L-}{$U-}   {$LOAD MQOTP.dumpfile}       Memtypes, QuickDraw, OSIntf, ToolIntf, PackIntf,	 {$LOAD Globals.dumpfile}   {$U Globals.p}  Globals;	 {$LOAD}{$U+}{$SETC DebugFlg:=FALSE}PROCEDURE PlanMove;IMPLEMENTATION{$S ArtfPers}{*************************************************************************}FUNCTION Rnd64: Integer;BEGIN  Rnd64:=Random div 512;END;{*************************************************************************}FUNCTION Rnd32: Integer;BEGIN  Rnd32:=Random div 1024;END;{*************************************************************************}FUNCTION Rnd16: Integer;BEGIN  Rnd16:=Random div 2048;END;{*************************************************************************}FUNCTION Rnd8: Integer;BEGIN  Rnd8:=Random div 4096;END;{*************************************************************************}PROCEDURE ClearSntc;VAR i: Integer;BEGIN  FOR i:=1 TO SntcLeng DO Sentence[Me,i]:=0;  Sentence[Me,SubjectA]:=Me;END;{********************************************************************************}PROCEDURE ChgLove(HowMuch: Integer);VAR x:  Integer;BEGIN  HowMuch:=HowMuch*(4-Level);  x:=Love[Me,Him]+(HowMuch div 4);  IF x>127 THEN x:=127;  IF x<-127 THEN x:=-127;  Love[Me,Him]:=x;    x:=LoveMood[Me]+HowMuch;  IF x>127 THEN x:=127;  IF x<-127 THEN x:=-127;  LoveMood[Me]:=x;END;{********************************************************************************}PROCEDURE ChgTrust(HowMuch: Integer);VAR x:  Integer;BEGIN  HowMuch:=HowMuch*(4-Level);  x:=Trust[Me,Him]+(HowMuch div 4);  IF x>127 THEN x:=127;  IF x<-127 THEN x:=-127;  Trust[Me,Him]:=x;  x:=TrstMood[Me]+HowMuch;  IF x>127 THEN x:=127;  IF x<-127 THEN x:=-127;  TrstMood[Me]:=x;END;{********************************************************************************}PROCEDURE ChgFear(HowMuch: Integer);VAR x:  Integer;BEGIN  HowMuch:=HowMuch*(4-Level);  x:=Fear[Me,Him]+(HowMuch div 4);  IF x>127 THEN x:=127;  IF x<-127 THEN x:=-127;  Fear[Me,Him]:=x;    x:=FearMood[Me]+HowMuch;  IF x>127 THEN x:=127;  IF x<-127 THEN x:=-127;  FearMood[Me]:=x;END;{*************************************************************************}PROCEDURE GoHome;BEGIN {return home}  ClearSntc;  Sentence[Me,VerbA]:=WGo;  Sentence[Me,ObjectA1]:=Me+56;END;{*************************************************************************}PROCEDURE SayGoodBye;BEGIN {return home}  ClearSntc;  Sentence[Me,VerbA]:=WGoodBye;  Sentence[Me,ObjectA1]:=Him;END;{*************************************************************************}PROCEDURE Express(Feeling: Integer);VAR  i,x:	Integer;  SaidBefore:	Boolean;BEGIN  i:=DlogIndx[Me];  x:=i-10;  SaidBefore:=TRUE;  WHILE (i>0) & SaidBefore & (i>x) DO	BEGIN	  IF (DlogHist[Me,i,VerbA]<>WSayFeel) THEN SaidBefore:=FALSE;	  i:=i-1;	END;  IF NOT SaidBefore THEN    BEGIN  	  ClearSntc;	  Sentence[Me,VerbA]:=WSayFeel;	  Sentence[Me,ObjectA1]:=Him;	  Sentence[Me,ObjectA2]:=Feeling;	  FoundPlan:=TRUE;	  CASE Feeling OF		WSTalk:   MakeAFace(Him,25);		WFlatter: MakeAFace(Him,29);		WTrust:   MakeAFace(Him,22);		WFear:    MakeAFace(Him,21);		WLove:    MakeAFace(Him,26);		WNFear:   MakeAFace(Him,13);		WNTrust:  MakeAFace(Him,24);		WNLove:   MakeAFace(Him,23);		WForgive: MakeAFace(Him,27);		WAnger:   MakeAFace(Him,3);		WThanks:  MakeAFace(Him,28);		WApolgz:  MakeAFace(Him,14);		WDeride:  MakeAFace(Him,10);	  END;	END;END;{*************************************************************************}PROCEDURE TellHim(Who,ToWhom: Integer);BEGIN  ClearSntc;  Sentence[Me,VerbA]:=WTell;  Sentence[Me,ObjectA1]:=Him;  Sentence[Me,ObjectA2]:=WThat;  Sentence[Me,SubjectB]:=Who;  Sentence[Me,VerbB]:=WBetray;  Sentence[Me,ObjectB1]:=ToWhom;  FoundPlan:=TRUE;  MakeAFace(Him,5);END;{*************************************************************************}FUNCTION SearchHist(WhoDoneIt: Integer; ToHimFlg: Boolean): Boolean;VAR  i: Integer;  SearchFlag: Boolean;  TempFlg1,TempFlg3:  Boolean;BEGIN  i:=1;  SearchFlag:=FALSE;  WHILE (i<=HistIndx) AND NOT SearchFlag DO    BEGIN	  TempFlg1:=(HstWrd1H^^[i]=WhoDoneIt);	  TempFlg3:=(HstWrd3H^^[i]=Him);	  IF NOT ToHimFlg THEN TempFlg3:=NOT TempFlg1;	  IF TempFlg1 & TempFlg3 	    & NOT HstKnowH[i,Him] & HstKnowH[i,Me] THEN SearchFlag:=TRUE;	  i:=i+1;    END;  SearchHist:=SearchFlag;END;{*************************************************************************}PROCEDURE SetSntc(Word2,Word3,Word4,Word5,Word6,Word7,Word8: Integer);BEGIN   ClearSntc;  Sentence[Me,VerbA]:=Word2;  Sentence[Me,ObjectA1]:=Word3;  Sentence[Me,ObjectA2]:=Word4;  Sentence[Me,SubjectB]:=Word5;  Sentence[Me,VerbB]:=Word6;  Sentence[Me,ObjectB1]:=Word7;  Sentence[Me,ObjectB2]:=Word8;  FoundPlan:=TRUE;END;{*************************************************************************}FUNCTION SearchDlog(VerbExp,Obj1Exp,Obj2Exp: Integer): Boolean;VAR  i,x:  	Integer;  TempFlg1: Boolean;BEGIN  TempFlg1:=FALSE;  x:=DlogIndx[Me];  IF x>0 THEN	BEGIN	  i:=1;	  WHILE (i<=x) AND NOT TempFlg1 DO		BEGIN		  IF (DlogHist[Me,i,VerbA]=VerbExp) &		     (DlogHist[Me,i,ObjectA1]=Obj1Exp) &		     (DlogHist[Me,i,ObjectA2]=Obj2Exp) THEN TempFlg1:=TRUE;		  i:=i+1;		END;	END;  SearchDlog:=TempFlg1;END;{*************************************************************************}FUNCTION GoodDeal(Victim1,Victim2: Integer): Integer;VAR  Temp,Obligation,LoveThem,i,k,Desperation:	Integer;BEGIN  Temp:=Beneficence[Him,Me]-Beneficence[Me,Him];  Obligation:=Duty[Me]*Temp*2;  Temp:=Love[Me,Victim1]+Love[Me,Victim2];  IF Temp>0 THEN LoveThem:=(Loyalty[Me]*Temp) div MaxPers  			ELSE LoveThem:=Temp;  Temp:=2*Trust[Me,Him]+TrstMood[Me]+Obligation-LoveThem+DesLiked[Me]  		+Desperation;  IF NBetray[Me,Victim2,Day] THEN Temp:=Temp-4*Integrity[Me];  IF NAttack[Me,Victim1] THEN Temp:=Temp-Integrity[Me];  IF NAttack[Victim1,Me] THEN Temp:=Temp-Gullble[Me];  GoodDeal:=Temp;  {$IFC DebugFlg}  DealCount:=DealCount+1;  IF DealCount>16 THEN    BEGIN	  DealCount:=16;	  FOR i:=1 TO 15 DO	    BEGIN		  DealTemp[i]:=DealTemp[i+1];		  DealDesp[i]:=DealDesp[i+1];		  DealOblg[i]:=DealOblg[i+1];		  DealTrst[i]:=DealTrst[i+1];		  DealTrMd[i]:=DealTrMd[i+1];		  DealLove[i]:=DealLove[i+1];		END;	END;  DealTemp[DealCount]:=Temp;  DealDesp[DealCount]:=Desperation;  DealOblg[DealCount]:=Obligation;  DealTrst[DealCount]:=Trust[me,Him];  DealTrMd[DealCount]:=TrstMood[Me];  DealLove[DealCount]:=LoveThem;  {$ENDC}END;				{*************************************************************************}PROCEDURE WontBetray;BEGIN  SetSntc(WNBetray,Him,0,0,0,0,0);  FoundPlan:=TRUE;  MakeAFace(Him,22);END;{*************************************************************************}PROCEDURE WontAttack;BEGIN  SetSntc(WNAttack,Him,0,0,0,0,0);  FoundPlan:=TRUE;  MakeAFace(Him,22);END;{*************************************************************************}PROCEDURE Ignore;VAR  i,j,k,GotI,GotJ,GotK,GotL,x,Temp1,Temp2:  Integer;  LoveMH,TrustMH,FearMH,Besti,Bestj,BestDeal,ThisDeal:	Integer;  m,n,BestK,BestL:	Integer;  TempFlg1,TempFlg3:  Boolean;BEGIN  LoveMH:=Love[Me,Him];  TrustMH:=Trust[Me,Him];  FearMH:=Fear[Me,Him];  j:=1;  WHILE (j<=HistIndx) & NOT FoundPlan DO	BEGIN	  TempFlg1:=(HstWrd1H^^[j]=Him);	  TempFlg3:=(HstWrd3H^^[j]=Me);	  IF TempFlg1 & TempFlg3 & HstKnowH[j,Me] THEN	    BEGIN		  SetSntc(WAccuse,Him,WThat,Him,WBetray,Me,0);		  MakeAFace(Him,19);		  ChgTrust(-16);		  ChgFear(8);		  ChgLove(-8);		END;	  j:=j+1;	END; {of WHILE statement}  IF NOT FoundPlan & (NBetrayCount[Him,Me]>0) THEN	BEGIN	  SetSntc(WAccuse,Him,WThat,Him,WBBetray,Me,0);	  MakeAFace(Him,19);	  ChgTrust(-32);	  ChgFear(8);	  ChgLove(-8);	END;  IF NOT FoundPlan & (NAttackCount[Him,Me]>0) THEN	BEGIN	  SetSntc(WAccuse,Him,WThat,Him,WBAttack,Me,0);	  MakeAFace(Him,19);	  ChgTrust(-32);	  ChgFear(8);	  ChgLove(-8);	END;    IF NOT FoundPlan THEN    BEGIN {I tell him a fact?}	  Temp1:=LoveMH+LoveMood[Me]+2*(TrustMH+TrstMood[Me]);	  Temp1:=Temp1+(FearMH div 4)-4*Secret[Me]+4*DesLiked[Me];	  FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) & NOT FoundPlan THEN		BEGIN		  Temp2:=((Loyalty[Me]*Love[Me,i]) div MaxPers)+(Fear[Me,i] div 4);		  IF (Temp1>Temp2) & SearchHist(i,TRUE) THEN TellHim(i,Him);	    END; {of FOR-loop}    END; {of tell-case}  IF NOT FoundPlan & ((Rnd16>4) | (DlogIndx[Me]=0)) THEN    BEGIN {ask a question}	  {check to make sure he hasn't already answered question with 'nobody'}	  TempFlg3:=FALSE;	  x:=DlogIndx[Him];	  IF x>0 THEN		BEGIN		  i:=1;		  WHILE (i<=x) AND NOT TempFlg3 DO			BEGIN			  IF (DlogHist[Him,i,SubjectB]=WNobody) &			     (DlogHist[Him,i,ObjectB1]=Me) THEN TempFlg3:=TRUE;			  i:=i+1;			END;		END;	  x:=DlogIndx[Me];	  k:=x-DlogIndx[Him]+1;	  IF x>0 THEN		BEGIN		  i:=1;		  WHILE (i<=x) & ((i+k)<=DlogMax) & NOT TempFlg3 DO			BEGIN			  IF (DlogHist[Me,i,VerbA]=WAsk) &			     (DlogHist[Him,i+k,ObjectA2]=WAnger) THEN TempFlg3:=TRUE;			  i:=i+1;			END;		END;	  IF NOT TempFlg3 THEN	    BEGIN		  SetSntc(WAsk,Him,WThat,WWho,WBetray,Me,0);		  MakeAFace(Him,6);		END;	END; {of ask-question considerations}  IF NOT FoundPlan THEN    BEGIN {promise no betray?}	  IF NOT SearchHist(Me,TRUE) THEN	    BEGIN		  TempFlg3:=FALSE;	  	  FOR i:=1 TO NumChars DO IF (i<>Me) & NOT TempFlg3 THEN			  TempFlg3:=(Love[Me,i]>LoveMH) | NBetray[Me,i,Day];		  IF NOT TempFlg3 THEN WontBetray;		END;	END;  IF NOT FoundPlan THEN    BEGIN {promise no attack -- because I love him?}	  TempFlg3:=FALSE;	  FOR i:=1 TO NumChars DO IF (i<>Me) & NOT TempFlg3 THEN		  TempFlg3:=(Love[Me,i]>LoveMH) | NAttack[Me,i];	  IF NOT TempFlg3 & (LoveMH>48) THEN WontAttack;	END;	  IF NOT FoundPlan THEN     BEGIN  {promise no attack -- because he is unattackable?}	  IF (AuraCnt[1,Him,Me]=AuraCnt[2,Him,Me])	   & (AuraCnt[1,Him,Me]=AuraCnt[3,Him,Me])	   & (AuraCnt[1,Him,Me]>=0) & NOT NAttack[Me,Him] THEN WontAttack;	END;    IF NOT FoundPlan & ((LoveMH div 4)+Integrity[Me]<-8) & NOT NAttack[Me,Him] THEN    BEGIN {promise no attack -- because I plan to GET him!}	  WontAttack;	END;  IF NOT FoundPlan THEN	BEGIN {offer him a deal?}	  BestDeal:=32; {minumum criterion for offering a deal}	  Besti:=0;	  Bestj:=0;	  FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) THEN	    BEGIN		  FOR j:=1 TO NumChars DO IF (j<>Me) & (j<>Him) THEN			BEGIN			  ThisDeal:=GoodDeal(i,j);			  IF ThisDeal>BestDeal THEN				BEGIN				  GotK:=0;				  FOR k:=1 TO 3 DO					IF (AuraCnt[k,i,Me]<0) & (AuraCnt[k,i,Him]>=0) THEN					  GotK:=k;				  IF GotK>0 THEN					BEGIN					  GotL:=0;					  FOR k:=1 TO 3 DO						IF (AuraCnt[k,j,Me]>=0) & (AuraCnt[k,j,Him]<0) THEN						  GotL:=k;					  IF GotL>0 THEN						BEGIN {has this deal already been offered?}						  x:=DlogIndx[Me];						  IF x>0 THEN							BEGIN							  m:=1;							  TempFlg1:=FALSE;							  WHILE (m<=x) & NOT TempFlg1 DO								BEGIN								  IF (DlogHist[Me,m,4]=j) & (DlogHist[Me,m,7]=i)								    THEN TempFlg1:=TRUE;								  m:=m+1;								END;							  IF NOT TempFlg1 THEN								BEGIN {this deal not previously offered}								  BestDeal:=ThisDeal;								  Besti:=i;								  Bestj:=j;								  Bestk:=GotK;								  BestL:=GotL;								END;							END;						END;					END;				END;			END;		END;	  IF (Besti>0) & (Bestj>0) THEN		SetSntc(WReveal,Him,Bestj,BestL+35,WReveal,Besti,BestK+35);  	  IF FoundPlan THEN MakeAFace(Him,20);	END; {test for offering a deal}	  IF DlogIndx[Me]<DlogMax THEN    BEGIN	  IF NOT FoundPlan & (Rnd8>4) & (FearMH<-32) & (LoveMH<-32) THEN Express(WDeride);	  IF NOT FoundPlan & (Rnd8>4) THEN Express(WFlatter);	  IF NOT FoundPlan & (DlogIndx[Me]<2) THEN Express(WSTalk);	END;END;{*************************************************************************}PROCEDURE ProcessFeelings(PrevFeel: Integer);VAR  i,Temp1,Temp2,LastFeel:	Integer;  LoveMH,TrustMH,FearMH:	Integer;  BetrayFlag,TempFlg1,TempFlg3:	Boolean;BEGIN  LoveMH:=Love[Me,Him];  TrustMH:=Trust[Me,Him];  FearMH:=Fear[Me,Him];  LastFeel:=LastSntc[Me,ObjectA2];  CASE PrevFeel OF    WTrust: 	  BEGIN		IF (TrustMH>20) & (LastFeel<>WTrust) THEN Express(WTrust);		IF (TrustMH<-20) & (LastFeel<>WNTrust) THEN Express(WNTrust);	  END;	WFear:	  BEGIN		IF (FearMH>20) & (LastFeel<>WFear) THEN Express(WFear);		IF (FearMH<-20) & (LastFeel<>WNFear) THEN Express(WNFear);	  END;	WLove:	  BEGIN		IF (LoveMH>20) & (LastFeel<>WLove) THEN Express(WLove);		IF (LoveMH<-20) & (LastFeel<>WNLove) THEN Express(WNLove);	  END;	WNFear:	  BEGIN		IF (FearMH>20) & (LastFeel<>WFear) THEN Express(WFear);		IF (FearMH<-20) & (LastFeel<>WNFear) THEN Express(WNFear);	  END;	WNTrust:	  BEGIN		IF (TrustMH>20) & (LastFeel<>WTrust) THEN Express(WTrust);		IF (TrustMH<-20) & (LastFeel<>WNTrust) THEN Express(WNTrust);	  END;	WNLove:	  BEGIN		IF (LoveMH>20) & (LastFeel<>WLove) THEN Express(WLove);		IF (LoveMH<-20) & (LastFeel<>WNLove) THEN Express(WNLove);	  END;	WAnger: 	  BEGIN	    ChgFear(16);		ChgLove(-2*Pride[Me]);		Temp1:=DlogIndx[Me];		Temp2:=DlogIndx[Him];		IF (Temp1>=2) AND (Temp2>=2) THEN		  BEGIN			IF (DlogHist[Me,Temp1,ObjectA2]=WAnger) 			 & (DlogHist[Me,Temp1-1,ObjectA2]=WAnger) 			 & (DlogHist[Him,Temp2,ObjectA2]=WAnger) 			 & (DlogHist[Him,Temp2-1,ObjectA2]=WAnger) THEN			  BEGIN				FoundPlan:=TRUE;				SayGoodBye;				MakeAFace(Him,3);			  END;		  END;		IF NOT FoundPlan & (FearMH<-50) THEN Express(WDeride);		IF NOT FoundPlan & (2*Temper[Me]>FearMH) THEN Express(WAnger);		IF NOT FoundPlan & (FearMH<-20) THEN Express(WNFear);		IF NOT FoundPlan & ((FearMH div 4)>32) THEN Express(WApolgz);		IF NOT FoundPlan & (LoveMH<-20) THEN Express(WNLove);	  END; {of WAnger subcase}	WApolgz:	  BEGIN		ChgFear(-24);		ChgTrust(Gullble[Me]);		IF LoveMH+4*DesLiked[Me]>40 THEN Express(WForgive);		IF NOT FoundPlan & (LoveMH>20) THEN Express(WLove);		IF NOT FoundPlan & (FearMH<-40) & (LoveMH<-40) THEN Express(WDeride);	  END;	WDeride:	  BEGIN		ChgLove(-16);		ChgFear(8);		IF (5*Pride[Me]-LoveMH>50) THEN Express(WAnger);		IF NOT FoundPlan & (FearMH<-40) & (LoveMH<-40)			THEN Express(WDeride);	  END;	WFlatter:	  BEGIN		ChgLove(Gullble[Me]+Pride[Me]);		ChgTrust(Gullble[Me]-8);		IF (LoveMH<-20) & (TrustMH>40) THEN Express(WThanks);		IF NOT FoundPlan & (TrustMH<-40) & (LoveMH<-20) & 		  (LastSntc[Me,ObjectA2]<>WFlatter) THEN Express(WFlatter);		IF NOT FoundPlan & (TrustMH<-20) THEN Express(WNTrust);		IF NOT FoundPlan & (LoveMH>20) THEN Express(WLove);	  END;	WForgive:	  BEGIN		ChgLove(8);		IF LoveMH>0 THEN Express(WThanks);		IF NOT FoundPlan & (FearMH>40) THEN Express(WFlatter);	  END;	WSTalk:	  BEGIN	    ChgLove(4);		IF (LoveMood[Me]>0) & (LoveMood[Me]<40) & (Secret[Me]<9) &		  (LastSntc[Me,ObjectA2]<>WSTalk) THEN Express(WSTalk);		IF NOT FoundPlan & (TrustMH<-20) THEN Express(WNTrust);	  END;	WThanks:	  BEGIN	    ChgLove(4);	  END;	END;END;{*************************************************************************}PROCEDURE Agree;BEGIN  ClearSntc;  Sentence[Me,VerbA]:=WAgree;  Sentence[Me,ObjectA1]:=Him;  FoundPlan:=TRUE;  MakeAFace(Him,20);END;{*************************************************************************}FUNCTION Betrayal(Suspect: Integer): Integer;VAR  i: Integer;  TempFlag: Boolean;BEGIN  i:=1;  TempFlag:=FALSE;  WHILE (i<=HistIndx) AND NOT TempFlag DO	BEGIN	  IF (HstWrd1H^^[i]=Suspect) & NOT HstKnowH[i,Him] & HstKnowH[i,Me]		THEN TempFlag:=TRUE;	  i:=i+1;	END;  IF TempFlag THEN Betrayal:=HstWrd3H^^[i-1] ELSE Betrayal:=0;END;{*************************************************************************}{$IFC DebugFlg}PROCEDURE FlagError;BEGIN  IF Sentence[Me,ObjectA1]>NumChars THEN	BEGIN 	  MoveTo(100,100);	  DrawString('LastSntc error: bad ObjectA1!: ');	  MyWrite(Sentence[Me,ObjectA1]);	  FoundPlan:=FALSE;	  ClearSntc;	END;END;{$ENDC}{*************************************************************************}{FUNCTION BestVictim(OldVictim1,OldVictim2: Integer; InvertFlg: Boolean; VAR Besti,Bestk: Integer): Boolean;VAR  i,k,BestFig:	Integer;  Temp1,Temp2:	Boolean;BEGIN  BestFig:=0;   Besti:=0;  FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) THEN	BEGIN	  FOR k:=1 TO 3 DO		BEGIN		  Temp1:=AuraCnt[k,i,Me]<0;		  Temp2:=AuraCnt[k,i,Him]>=0;		  IF InvertFlg THEN			BEGIN			  Temp1:= NOT Temp1;			  Temp2:= NOT Temp2;			END;		  IF Temp1 & Temp2 & (Love[Me,i]<BestFig) THEN			BEGIN			  BestFig:=Love[Me,i];			  Besti:=i;			  Bestk:=k;			END;		END; 	END;   IF Besti>0 THEN    BEGIN	  IF InvertFlg THEN BestVictim:=(GoodDeal(OldVictim1,Besti)>32)				   ELSE BestVictim:=(GoodDeal(Besti,OldVictim2)>32);	END  ELSE BestVictim:=FALSE;END;}{*************************************************************************}FUNCTION Dialog: Boolean;VAR  i,j,k,BestFig,Besti,Bestk,x,y,A1,A2,TrustMH,Temp1,Temp2:	Integer;  LoveMH,FearMH,DutyMH:	Integer;  LSubjA,LVerbA,LObjA1,LObjA2,LSubjB,LVerbB,LObjB1,LObjB2:	Integer;  ToldFlag,KnowFlag,TempFlg1,TempFlg2,TempFlg3:	Boolean;BEGIN  {MakeAFace(Him,35); clear out face area}  IF Him=Player THEN FillRect(FaceRect,DiurnalP);  FoundPlan:=FALSE;  ThatGuy:=0;  ClearSntc;  LSubjA:=LastSntc[Him,SubjectA];  LVerbA:=LastSntc[Him,VerbA];  LObjA1:=LastSntc[Him,ObjectA1];  LObjA2:=LastSntc[Him,ObjectA2];  LSubjB:=LastSntc[Him,SubjectB];  LVerbB:=LastSntc[Him,VerbB];  LObjB1:=LastSntc[Him,ObjectB1];  LObjB2:=LastSntc[Him,ObjectB2];  TrustMH:=Trust[Me,Him];  LoveMH:=Love[Me,Him];  FearMH:=Fear[Me,Him];  Temp1:=Beneficence[Him,Me]-Beneficence[Me,Him];  DutyMH:=Duty[Me]*Temp1;  IF NOT HelloFlg[Me] THEN    BEGIN	  IF LoveMH>64 THEN x:=WWarm	    ELSE		  BEGIN		    IF LoveMH>32 THEN x:=WNice			  ELSE			    BEGIN				  IF LoveMH>-32 THEN				    BEGIN					  IF FearMH>-16 THEN					    BEGIN						  IF TrustMH>0 THEN x:=WSincere ELSE x:=WFormal;						END					  ELSE x:=WHaughty;					END				  ELSE				    BEGIN					  IF FearMH>-16 THEN x:=WCool ELSE x:=WThreaten;					END;				END;		  END;	  SetSntc(WGreet,Him,x,0,0,0,0);	  CASE x OF	    WWarm: MakeAFace(Him,25);	    WNice: MakeAFace(Him,29);		WSincere: MakeAFace(Him,22);	    WCool: MakeAFace(Him,31);		WThreaten: MakeAFace(Him,34);		WHaughty: MakeAFace(Him,13);	    WFormal: MakeAFace(Him,1);	  END;	END;  CASE LVerbA OF    WGreet: 	  CASE LObjA2 OF	    WWarm: 		  BEGIN		    IF LoveMH>64 THEN ChgLove(16)			ELSE BEGIN ChgLove(Gullble[Me]); ChgTrust(MaxPers-Gullble[Me]); END;		  END;	    WNice: IF LoveMH>32 THEN ChgLove(8)			ELSE BEGIN ChgLove(Gullble[Me]); ChgTrust(MaxPers-Gullble[Me]); END;		WSincere: IF TrustMH>0 THEN ChgTrust(16) ELSE ChgTrust(-16);	    WCool: MakeAFace(Him,31);		WThreaten:		  BEGIN		    ChgLove(-8);			IF FearMH<16 THEN ChgFear(-8) ELSE ChgFear(8);		  END;		WHaughty: IF FearMH<16 THEN ChgFear(-8) ELSE ChgFear(8);	  END;	WReveal: BEGIN	  ThatGuy:=LObjA2;	  ChgTrust(4);	  A1:=Love[Me,LObjA2];	  A2:=Love[Me,LObjB1];	  {first check to see if he hasn't already offered me this deal}	  x:=DlogIndx[Him];	  y:=DlogIndx[Me]-x+1;	  IF (x>1) & NOT FoundPlan THEN		BEGIN		  BestFig:=0;		  FOR i:=1 TO x-1 DO		    BEGIN			  TempFlg1:=TRUE;			  FOR j:=1 TO SntcLeng DO				IF DlogHist[Him,i,j]<>LastSntc[Him,j] THEN				  TempFlg1:=FALSE;			  IF TempFlg1 THEN TempFlg1:=(DlogHist[Me,i+y,VerbA]=WReject);			  IF TempFlg1 THEN BestFig:=BestFig+1;			END;		  ChgTrust(-4);		  ChgLove(-4);		  IF (BestFig*(Temper[Me]-DutyMH)>0) THEN Express(WAnger);		END;	  Temp1:=0;	  IF LastSntc[Me,ObjectA2]=WApolgz THEN Temp1:=64;	  IF NOT FoundPlan & (GoodDeal(LObjA2,LObjB1)+Temp1>32) THEN		BEGIN {I accept his offer}		  ChgTrust(4);		  ChgLove(8);		  Agree;		END;	  {These screw up the auracount information	  IF NOT FoundPlan THEN		BEGIN I make a counteroffer replacing his first victim		  IF BestVictim(LObjA2,LObjB1,FALSE,Besti,Bestk) THEN		    SetSntc(WReveal,Him,Besti,Bestk+35,LVerbB,LObjB1,LObjB2);		END;	  IF NOT FoundPlan THEN		BEGIN I make a counteroffer replacing his second victim		  IF BestVictim(LObjA2,LObjB1,TRUE,Besti,Bestk) THEN 		    SetSntc(WReveal,Him,LObjA2,LSubjB,LVerbB,Besti,Bestk+35);		END;}	  IF NOT FoundPlan THEN		BEGIN {I reject his offer}  		  ClearSntc;		  Sentence[Me,VerbA]:=WReject;		  FoundPlan:=TRUE;		  MakeAFace(Him,33);		END;	  END; {of WReveal case}	WAsk:	  BEGIN	   {first check to see if he hasn't already asked me this question}	    x:=DlogIndx[Him];	    IF x>1 THEN		  BEGIN		    BestFig:=0;			k:=DlogIndx[Me]-x+1;		    FOR i:=1 TO x-1 DO IF ((i+k)<=DlogMax) THEN		      BEGIN			    TempFlg1:=TRUE;			    FOR j:=1 TO SntcLeng DO				 IF DlogHist[Him,i,j]<>LastSntc[Him,j] THEN TempFlg1:=FALSE;				{I'm uncertain about this index "i+k" in following expression}			    IF TempFlg1 & (DlogHist[Me,i+k,5]=WNobody) THEN BestFig:=BestFig+1;			  END;		    IF BestFig*(Temper[Me]-DutyMH)>0 THEN			  BEGIN {he asked it before, so yell at him}				ChgLove(-8);			    Express(WAnger);			  END;		  END;		IF NOT FoundPlan THEN		  BEGIN			ToldFlag:=FALSE;			KnowFlag:=FALSE;			Temp2:=DutyMH+TrustMH+TrstMood[Me]+(FearMH div 4)-2*Secret[Me];			FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) & NOT FoundPlan THEN			  BEGIN		  		Temp1:=((Loyalty[Me]*Love[Me,i]) div MaxPers)+(Fear[Me,i] div 4)+80;				IF SearchHist(i,TRUE) THEN				  BEGIN				    KnowFlag:=TRUE;					IF Temp2>Temp1 THEN 					  BEGIN					    ToldFlag:=TRUE;						TellHim(i,Him);					  END;				  END;			  END;			IF NOT KnowFlag THEN TellHim(WNobody,Him);			IF KnowFlag AND NOT ToldFlag THEN			  BEGIN {I know but I didn't tell; offer something else?}				Temp2:=DutyMH+TrustMH+TrstMood[Me]+(FearMH div 4)-2*Secret[Me];				FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) & NOT FoundPlan THEN				  BEGIN					Temp1:=Love[Me,i]+(Fear[Me,i] div 4)+80;				    IF (Temp2>Temp1) & SearchHist(i,FALSE) THEN					  BEGIN						ToldFlag:=TRUE;						TellHim(i,HstWrd3H^^[i]);					  END;				  END;			  END;		  END; {of NOT FoundPlan IF}      END; {of WAsk case}	WAccuse:	  BEGIN	    ChgLove(-8);		ChgFear(8);	    Temp2:=(Pride[Me]*5);	    IF (LoveMH+FearMH)>Temp2 THEN		  BEGIN		    Express(WApolgz);			ChgFear(8);		  END;		Temp1:=2*(Pride[Me]+Temper[Me])-FearMH-LoveMH;		IF NOT FoundPlan & (Temp1>100) THEN		  BEGIN		    Express(WAnger);			ChgFear(4);			ChgLove(-4);		  END;		Temp1:=Temp1-FearMH;		IF NOT FoundPlan & (Temp1>100) THEN		  BEGIN		    Express(WDeride);			ChgFear(-8);		  END;	  END; {of WAccuse case}	WSayFeel: ProcessFeelings(LObjA2);	WReject:	  BEGIN		ChgLove(-4);		ChgTrust(-4);	    Temp1:=LoveMH+FearMH-7*Pride[Me];		IF (Temp1>0) & (LastSntc[Me,VerbA]<>WBeg) THEN		  BEGIN			FOR i:=1 TO SntcLeng DO Sentence[Me,i]:=LastSntc[Me,i];			Sentence[Me,VerbA]:=WBeg;			FoundPlan:=TRUE;			MakeAFace(Him,32);			{$IFC DebugFlg} FlagError; {$ENDC}		  END;		Temp1:=4*(Temper[Me]-DesLiked[Me])-FearMH;		IF NOT FoundPlan & (Temp1>70) & (LastSntc[Me,VerbA]<>WBeg) 		    & (LastSntc[Me,VerbA]<>WThreat) THEN		  BEGIN			FOR i:=1 TO SntcLeng DO Sentence[Me,i]:=LastSntc[Me,i];			Sentence[Me,VerbA]:=WThreat;			FoundPlan:=TRUE;			MakeAFace(Him,34);			{$IFC DebugFlg} FlagError; {$ENDC}		  END;		Temp1:=4*Temper[Me]-FearMH-LoveMH;		IF NOT FoundPlan & (Temp1>60) THEN Express(WAnger);	  END; {of WReject case}	WThreat:	  BEGIN	    ThatGuy:=LObjA2;		ChgLove(-4);		ChgFear(8);		Temp1:=(4-Level)*(FearMH-Fear[Me,LObjB1]);	    IF (LVerbB=WReveal) & (GoodDeal(LObjA2,LObjB1)+Temp1>32) THEN Agree;		IF LObjA2=WThat THEN		  BEGIN		    ThatGuy:=0;			Temp2:=LoveMH+TrustMH+TrstMood[Me]+FearMH-4*Secret[Me];			FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) & NOT FoundPlan THEN			  BEGIN				Temp1:=Love[Me,i]+Fear[Me,i]+80;			    IF (Temp2>Temp1) & SearchHist(i,TRUE) THEN TellHim(i,Him);			  END;		  END; {of LObjA2=WThat IF}		IF NOT FoundPlan & (FearMH<-20) THEN Express(WNFear);	    Temp1:=4*(Temper[Me]+Pride[Me])-FearMH-LoveMH;		IF NOT FoundPlan & (Temp1>0) THEN Express(WAnger);	  END; {of WThreat case}	WBeg:	  BEGIN	    ThatGuy:=LObjA2;		ChgFear(-8);		Temp1:=LoveMH-Love[Me,LObjB1];	    IF (LVerbB=WReveal) & (GoodDeal(LObjA2,LObjB1)+Temp1>32) THEN Agree;		IF LObjA2=WThat THEN		  BEGIN		    ThatGuy:=0;			Temp2:=LoveMH+TrustMH+(FearMH div 8)+TrstMood[Me];			FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) & NOT FoundPlan THEN			  BEGIN				Temp1:=Love[Me,i]+Fear[Me,i]+80;			    IF (Temp2>Temp1) & SearchHist(i,TRUE) THEN TellHim(i,HIm);			  END;		  END; {of LObjA2=WThat IF}		IF NOT FoundPlan & (LoveMH<-20) THEN Express(WNLove);		IF NOT FoundPlan & (FearMH<-40) & (LoveMH<-40) THEN Express(WDeride);	  END;	WAgree:	  BEGIN		ChgLove(8);		ChgFear(-4);		ChgTrust(8);	    CASE LastSntc[Me,VerbA] OF		  WReveal: IF LoveMH<-30 THEN Express(WThanks);		  WBeg: IF LoveMH<40 THEN Express(WThanks);		  WThreat: IF FearMH<-60 THEN Express(WDeride);		END;	  END;	WTell:	  BEGIN	    IF (LSubjB<>Him) & (LSubjB<>WNobody) THEN ThatGuy:=LSubjB;	    IF (LastSntc[Me,VerbA]=WAsk) & (LObjB1=Me) & (LSubjB<>Him) THEN		  BEGIN {he answered my question}		    ChgTrust(8);		    {first try to tell him something useful in return}		    Temp2:=LoveMH+TrstMood[Me]+(FearMH div 4)-4*Secret[Me];			FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) & NOT FoundPlan THEN			  BEGIN				Temp1:=Love[Me,i]+(Fear[Me,i] div 4)+20;			    IF (Temp2>Temp1) & SearchHist(i,TRUE) THEN TellHim(i,Him);			  END;			IF NOT FoundPlan THEN 			  BEGIN {failed to give something useful, try something else}				Temp2:=LoveMH+TrustMH+TrstMood[Me]+(FearMH div 4);			    FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) & NOT FoundPlan THEN			  	  BEGIN					Temp1:=Love[Me,i]+(Fear[Me,i] div 4)+80;			    	IF (Temp2>Temp1) & SearchHist(i,FALSE) THEN TellHim(i,Him);			  	  END;			  END; {of NOT FoundPlan IF}			IF NOT FoundPlan & (LoveMH<-30) THEN Express(WThanks);			IF NOT FoundPlan & (LoveMH+LoveMood[Me]>80) THEN Express(WLove);  		    IF NOT FoundPlan & (TrustMH+TrstMood[Me]>80) THEN Express(WTrust);		  END; {of answered-my-question-IF}	    IF (LastSntc[Me,VerbA]=WAsk) & (LObjB1<>Me) THEN		  BEGIN {he dodged my question}		    ChgTrust(-16);			MakeAFace(Him,1);			IF Him=Player THEN MyWait(30);		    IF LoveMH+FearMH-5*Pride[Me]>0 THEN			  BEGIN {beg him}				FOR i:=1 TO SntcLeng DO Sentence[Me,i]:=LastSntc[Me,i];				Sentence[Me,VerbA]:=WBeg;				FoundPlan:=TRUE;				MakeAFace(Him,32);			  END;			IF NOT FoundPlan & (-FearMH>80) THEN			  BEGIN				FOR i:=1 TO SntcLeng DO Sentence[Me,i]:=LastSntc[Me,i];				Sentence[Me,VerbA]:=WThreat;				FoundPlan:=TRUE;				MakeAFace(Him,34);			  END;		    IF NOT FoundPlan & (4*Temper[Me]-FearMH-LoveMH>140)			  THEN Express(WAnger);		  END;		IF (LastSntc[Me,VerbA]<>WAsk) & NOT ((LSubjB=Him) & (LObjB1=Me)) THEN		  BEGIN {he genuinely volunteered this information!}		    ChgTrust(16);			IF (LObjB1<>Me) & (LSubjB<>WNobody) THEN			  BEGIN			    x:=Trust[Me,LSubjB];				x:=x-2;				IF x<-127 THEN x:=-127;				Trust[Me,LSubjB]:=x;			  END;			IF LSubjB<>WNobody THEN MakeAFace(Him,9);			IF Him=Player THEN MyWait(30);			Temp2:=LoveMH+TrustMH+TrstMood[Me]+(FearMH div 4);			FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) & NOT FoundPlan THEN			  BEGIN				Temp1:=Love[Me,i]+(Fear[Me,i] div 4)+60;				IF (Temp2>Temp1) & SearchHist(i,TRUE) THEN TellHim(i,Him);			  END;			FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) & NOT FoundPlan THEN			  BEGIN				Temp1:=Love[Me,i]+(Fear[Me,i] div 4)+100;				IF (Temp2>Temp1) & SearchHist(i,FALSE) THEN TellHim(i,Him);			  END;			IF NOT FoundPlan & (LoveMH<-40) THEN Express(WThanks);			IF NOT FoundPlan & (TrustMH>40) THEN Express(WTrust);			IF NOT FoundPlan & (TrustMH<-40) THEN Express(WNTrust);		  END;	  END; {of WTell case}	WNBetray:	  BEGIN	    ChgTrust(4*Gullble[Me]+2);		IF (TrustMH>20) THEN Express(WTrust);		IF NOT FoundPlan & (TrustMH<-20) THEN Express(WNTrust);	  END;	WNAttack:	  BEGIN	    ChgLove(4*Gullble[Me]);		IF (TrustMH>20) THEN Express(WTrust);		IF NOT FoundPlan & (TrustMH<-20) THEN Express(WNTrust);	  END;  END; {of gigantic CASE statement}    IF NOT FoundPlan THEN Ignore;  IF NOT FoundPlan THEN ClearSntc; {kludge!}  Dialog:=NOT FoundPlan;END;{*************************************************************************}PROCEDURE GoSomeWhere(NotHome: Boolean);VAR  NewLocn,Attempts,i:	Integer;  HitFlag:		Boolean;BEGIN  Attempts:=0;  REPEAT     NewLocn:=Abs(Rnd8)+1; 	Attempts:=Attempts+1;	HitFlag:=(NewLocn<=NumChars) & (NewLocn>0) & (CharLocn[NewLocn]=NewLocn);	IF HitFlag THEN	  BEGIN	    FOR i:=1 TO NumChars DO		  BEGIN		    IF (CharLocn[i]=-NewLocn) | (Sentence[i,ObjectA1]=NewLocn+56)		      THEN HitFlag:=FALSE;			IF (Visits[Me,i]>0) & (Random>0) THEN HitFlag:=FALSE;		  END;	  END;	IF NotHome & (NewLocn=Me) THEN HitFlag:=FALSE;  UNTIL HitFlag | (Attempts>8);  IF HitFlag THEN    BEGIN  	  Sentence[Me,VerbA]:=WGo;  	  Sentence[Me,ObjectA1]:=NewLocn+56;	END  ELSE     BEGIN IF NotHome THEN Sentence[Me,VerbA]:=WWait ELSE GoHome; END;END;{*************************************************************************}PROCEDURE PlanMove;VAR  i,k,BestFig,MyLocn,Temp,SumAuras:	 Integer;  WaitFlag:	Boolean;BEGIN  ClearSntc;  Sentence[Me,SubjectA]:=Me;  Him:=Interloc[Me];  MyLocn:=CharLocn[Me];  SumAuras:=-5;  FOR i:=1 TO NumChars DO IF (i<>Me) & (i<>Him) THEN	  FOR k:=1 TO 3 DO IF AuraCnt[k,i,Me]>=0 THEN SumAuras:=SumAuras+1;  Temp:=(1500-Time) div 8;  Desperation:=(1024*(6-SumAuras)) div Temp;  IF (Time>Sunset) AND (Time<Night) THEN    BEGIN	  IF MyLocn<>Me 	    THEN BEGIN IF GuestFlg[Me] THEN SayGoodBye ELSE GoHome; END	    ELSE IF Him>0 THEN SayGoodBye;	END;  IF Time<=Sunset THEN    BEGIN {daytime}	  IF (MyLocn<>Me) THEN	    BEGIN		  IF MyLocn>0 THEN	        BEGIN {in someone's home}	          IF Dialog THEN SayGoodBye;		    END;		  IF MyLocn<=0 THEN GoSomeWhere(FALSE);		END	  ELSE	    BEGIN {in my own home}		  IF Him>0 THEN		    BEGIN		      IF Dialog THEN SayGoodBye;		    END		  ELSE		    BEGIN {alone in my own home}			  WaitFlag:=FALSE;			  FOR i:=1 TO NumChars DO 			    IF (Sentence[i,VerbA]=WGo) & (Sentence[i,ObjectA1]=Me+56)			      THEN BEGIN Sentence[Me,VerbA]:=WWait; WaitFlag:=TRUE; END;				IF NOT WaitFlag THEN GoSomeWhere(TRUE);			END; {of alone-else}		END; {of in-my-home IF}	END; {of daytime IF}  {$IFC DebugFlg}  FOR i:=1 TO SntcLeng DO     BEGIN	  BestFig:=Sentence[Me,i];	  IF BestFig>0 THEN DebugVal[BestFig]:=DebugVal[BestFig]+1;	END;  {$ENDC}END;{*************************************************************************}END.