;   Shimmer;    BLANKS ON    STRING ASIS     PRINT OFF;     .INCLUDE TLAsm/SysEqu.Text;     .INCLUDE TLAsm/ToolEqu.Text;     .INCLUDE TLAsm/QuickTraps.Text     PRINT ONSHIMMER PROC      EXPORT ;;This procedure "shimmer-dissolves" a bitmap.;   The basic approach uses a sinwave table, 34 words long, passed to it.;   The sinwave table is actually a table of differences, not sines.;   It then sweeps through each scanline of the bitmap, shifting the bits in;   that scanline by the amount called for by the sinewave table.  A phase angle;   parameter is passed to this procedure and stored in D5; by repeatedly;   calling this procedure with incrementing values of the pass counter, the;   image waves ("shimmers") with time.	 This is NOT general-purpose code;;   it is hard-coded for a bitmap 128 pixels wide and 70 pixels high.  The;   height can readily be changed by just changing the loop termination constant;   for LP01, but the width is not readily changed, being assumed by such things;   as the number of loads, shifts, and stores used by the code.  It could be;   recoded for other widths by making that a loop and making the new width some;   multiple of 32 bits (that's the width of a long word).;      The dissolve is done through another table whose address is held in A2.;   This table shows up in the main code as "BitMask".  Note that it's length,;   34 longwords, is directly tied to the wavelength of the sinewave.  A random;   number passed to this procedure is used to select the bitmask values on any;   single pass, thereby giving the routine a more random dissolve.  I suppose;   that I could have just generated random numbers myself, but I was too lazy.;;register assignments:;  D0:  holds data to be shifted;  D1:  index to data in the bitmap;  D2:  holds amount of shift;  D3:  holds scan line counter;  D4:  index to SinTab (phase angle);  D5:  pass counter;  D6:  random integer;  A0:  address of bitmap;  A1:  address of SinTable;  A2:  address of bitmask table;  A3:  address of face image to dissolve in;  A4:  address of dissolve EOR/AND mask table;  A5:  address of the original image bitmap     LINK      A6,#0     MOVEM.L   D0-D7/A0-A5,-(A7)     MOVE.L    $8(A6),A1      ;SinTable address     MOVE.L    $C(A6),A0      ;BitMap address     MOVE.W    $10(A6),D5     ;pass counter     MOVE.L    $12(A6),A2     ;bitmask address     MOVE.W    $16(A6),D6     ;random integer from Pascal	 MOVE.L	   $18(A6),A3	  ;address of face image	 MOVE.L	   $1C(A6),A4	  ;address of MaskTabl	 MOVE.L	   $20(A6),A5	  ;addres of old bitmap     MOVEQ     #0,D3	      ;scan line counterLP01     MOVE.L	   D5,D1	 LSR.W	   #2,D1	 CMP.W	   #16,D1	 BLT.S	   X05	 MOVEQ	   #16,D1X05  ASL.W	   #4,D1	 MOVE.W	   D3,D0	 AND.W	   #$F,D0	 ADD.W	   D0,D1     ASL.W     #1,D1	      ;multiply by two to get longwords     MOVE.L    0(A4,D1),D4    ;load the bitmask     MOVE.W    D3,D1	      ;now calculate the index for the sinewave     ADD.W     D5,D1	      ;add in the time factor     EXT.L     D1	      	  ;prepare for division     MOVEQ     #34,D0	      ;the divisor     DIVU      D0,D1     SWAP      D1	          ;the remainder     ASL.W     #1,D1	      ;double value for grabbing integers     MOVE.W    0(A1,D1),D2    ;get the sinewave value from the table     BPL.S     X01	      	  ;if positive, shift right, else shift left     NEG.W     D2	          ;get a positive value for shifting     MOVE.W    D3,D1	      ;the scanline index, index for this loop (LP01)     MULU     #20,D1	      ;multiply by 20 because 20 bytes per scanline	 	 MOVE.L    16(A3,D1),D0   ;load the rightmost longword	 MOVE.L	   16(A5,D1),D7	  ;get face image longword	 EOR.L	   D7,D0     AND.L     D4,D0	      ;mask it	 EOR.L	   D7,D0     LSL.L     D2,D0	      ;shift it left D2 times     MOVE.L    D0,16(A0,D1)   ;store it back to the bitmap     MOVE.L    12(A3,D1),D0    ;and so on with the next four longwords...	 MOVE.L	   12(A5,D1),D7	  	 EOR.L	   D7,D0	 AND.L     D4,D0	 EOR.L	   D7,D0     ROXL.L    D2,D0	      ;except that for these we rotate, not shift     MOVE.L    D0,12(A0,D1)     MOVE.L    8(A3,D1),D0    	 MOVE.L	   8(A5,D1),D7	  	 EOR.L	   D7,D0     AND.L     D4,D0	 EOR.L	   D7,D0     ROXL.L    D2,D0	           MOVE.L    D0,8(A0,D1)     MOVE.L    4(A3,D1),D0	 MOVE.L	   4(A5,D1),D7	  	 EOR.L	   D7,D0     AND.L     D4,D0	 EOR.L	   D7,D0     ROXL.L    D2,D0     MOVE.L    D0,4(A0,D1)     MOVE.L    0(A3,D1),D0	 MOVE.L	   0(A5,D1),D7	  	 EOR.L	   D7,D0     AND.L     D4,D0	 EOR.L	   D7,D0     ROXL.L    D2,D0     MOVE.L    D0,0(A0,D1)     BRA.S     X02	      ;skip over the next chunkX01  MOVE.W    D3,D1	      ;same code as above, except that we shift right     MULU      #20,D1	      ;	  and start with the leftmost longword     MOVE.L    0(A3,D1),D0	 MOVE.L	   0(A5,D1),D7	  	 EOR.L	   D7,D0     AND.L     D4,D0	 EOR.L	   D7,D0     LSR.L     D2,D0     MOVE.L    D0,0(A0,D1)     MOVE.L    4(A3,D1),D0	 MOVE.L	   4(A5,D1),D7	  	 EOR.L	   D7,D0     AND.L     D4,D0	 EOR.L	   D7,D0     ROXR.L    D2,D0     MOVE.L    D0,4(A0,D1)     MOVE.L    8(A3,D1),D0	 MOVE.L	   8(A5,D1),D7	  	 EOR.L	   D7,D0     AND.L     D4,D0	 EOR.L	   D7,D0     ROXR.L    D2,D0     MOVE.L    D0,8(A0,D1)     MOVE.L    12(A3,D1),D0	 MOVE.L	   12(A5,D1),D7	  	 EOR.L	   D7,D0     AND.L     D4,D0	 EOR.L	   D7,D0     ROXR.L    D2,D0     MOVE.L    D0,12(A0,D1)     MOVE.L    16(A3,D1),D0	 MOVE.L	   16(A5,D1),D7	  	 EOR.L	   D7,D0     AND.L     D4,D0	 EOR.L	   D7,D0     ROXR.L    D2,D0     MOVE.L    D0,16(A0,D1)X02  ADDQ      #1,D3	      ;end of loop, now increment scanline counter     CMPI      #160,D3	     ;bottom of bitmap?     BNE       LP01     MOVEM.L   (A7)+,D0-D7/A0-A5   ;bye!     UNLK      A6     MOVE.L    (A7)+,A0     JMP       (A0)     END 